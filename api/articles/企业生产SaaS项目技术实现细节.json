{"title":"企业生产SaaS项目技术实现细节","uid":"e16c05f5e231a1a803fb1bd949e0f188","slug":"企业生产SaaS项目技术实现细节","date":"2024-03-25T11:47:27.000Z","updated":"2024-03-25T11:52:39.123Z","comments":true,"path":"api/articles/企业生产SaaS项目技术实现细节.json","keywords":null,"cover":null,"content":"<p><strong>一、关于数据源切换</strong></p>\n<p><strong>问：在项目中，如何实现企业数据源的动态切换？</strong></p>\n<p>答：为了实现企业数据源的动态切换，我们采用了Hibernate与ThreadLocal的结合。Hibernate作为ORM框架，能够简化数据库操作。而ThreadLocal可以在每个线程中存储一个变量副本，这样每个请求都能拥有独立的数据源。当请求到来时，我们通过ThreadLocal获取当前请求对应的企业数据源，并设置到Hibernate的Session中，从而实现了数据源的动态切换。</p>\n<p><strong>问：动态切换数据源的过程中，如何保证数据的安全性和准确性？</strong></p>\n<p>答：在数据源切换的过程中，我们采取了多种措施来保证数据的安全性和准确性。首先，我们在切换数据源之前，会对数据源进行严格的验证，确保数据源的合法性和有效性。其次，我们在使用Hibernate时，会开启事务管理，确保每个操作都是原子性的，防止数据不一致的情况发生。此外，我们还对所有的数据访问操作进行了严格的权限控制，只有经过身份验证和授权的用户才能访问相应的数据。</p>\n<p><strong>问：在实现数据源切换的过程中，有没有遇到什么技术难点？</strong></p>\n<p>答：在实现数据源切换的过程中，我们确实遇到了一些技术难点。其中最主要的问题是如何保证线程安全和数据一致性。由于多个线程可能同时访问ThreadLocal中的数据源信息，我们需要确保每个线程都能获取到正确的数据源，并且不会受到其他线程的影响。为了解决这个问题，我们采用了线程局部变量的方式，确保每个线程都有自己独立的数据源信息。同时，我们还对数据库操作进行了事务管理，确保数据的一致性和完整性。</p>\n<p><strong>问：</strong>Hibernate与MyBatis对比**</p>\n<p><strong>1 相同点</strong></p>\n<p>Hibernate与MyBatis都可以是通过SessionFactoryBuider由XML配置文件生成SessionFactory，然后由SessionFactory 生成Session，最后由Session来开启执行事务和SQL语句。</p>\n<p>其中SessionFactoryBuider，SessionFactory，Session的生命周期都是差不多的。Hibernate和MyBatis都支持JDBC和JTA事务处理。</p>\n<p><strong>2 不同点</strong></p>\n<p>（1）hibernate是全自动，而mybatis是半自动</p>\n<p>hibernate完全可以通过对象关系模型实现对数据库的操作，拥有完整的JavaBean对象与数据库的映射结构来自动生成sql。而mybatis仅有基本的字段映射，对象数据以及对象实际关系仍然需要通过手写sql来实现和管理。</p>\n<p>（2）hibernate数据库移植性远大于mybatis</p>\n<p>hibernate通过它强大的映射结构和hql语言，大大降低了对象与数据库（Oracle、MySQL等）的耦合性，而mybatis由于需要手写sql，因此与数据库的耦合性直接取决于程序员写sql的方法，如果sql不具通用性而用了很多某数据库特性的sql语句的话，移植性也会随之降低很多，成本很高。</p>\n<p>（3）hibernate拥有完整的日志系统，mybatis则欠缺一些</p>\n<p>hibernate日志系统非常健全，涉及广泛，包括：sql记录、关系异常、优化警告、缓存提示、脏数据警告等；而mybatis则除了基本记录功能外，功能薄弱很多。</p>\n<p>（4）mybatis相比hibernate需要关心很多细节</p>\n<p>hibernate配置要比mybatis复杂的多，学习成本也比mybatis高。但也正因为mybatis使用简单，才导致它要比hibernate关心很多技术细节。mybatis由于不用考虑很多细节，开发模式上与传统jdbc区别很小，因此很容易上手并开发项目，但忽略细节会导致项目前期bug较多，因而开发出相对稳定的软件很慢，而开发出软件却很快。hibernate则正好与之相反。但是如果使用hibernate很熟练的话，实际上开发效率丝毫不差于甚至超越mybatis。</p>\n<p>（5）sql直接优化上，mybatis要比hibernate方便很多</p>\n<p>由于mybatis的sql都是写在xml里，因此优化sql比hibernate方便很多。而hibernate的sql很多都是自动生成的，无法直接维护sql；虽有hql，但功能还是不及sql强大，见到报表等变态需求时，hql也歇菜，也就是说hql是有局限的；hibernate虽然也支持原生sql，但开发模式上却与orm不同，需要转换思维，因此使用上不是非常方便。总之写sql的灵活度上hibernate不及mybatis。</p>\n<p>（6）缓存机制上，hibernate要比mybatis更好一些</p>\n<p>MyBatis的二级缓存配置都是在每个具体的表-对象映射中进行详细配置，这样针对不同的表可以自定义不同的缓存机制。并且Mybatis可以在命名空间中共享相同的缓存配置和实例，通过Cache-ref来实现。</p>\n<p>而Hibernate对查询对象有着良好的管理机制，用户无需关心SQL。所以在使用二级缓存时如果出现脏数据，系统会报出错误并提示。</p>\n<p><strong>二、关于Spring的BeanPostProcessor扩展</strong></p>\n<p><strong>问：为什么选择实现Spring的BeanPostProcessor扩展接口？</strong></p>\n<p>答：实现Spring的BeanPostProcessor扩展接口可以让我们在Spring容器创建Bean的过程中进行自定义的处理。通过这个接口，我们可以暴露一些<strong>不需要进行身份验证</strong>的接口，提高系统的便捷性和灵活性。同时，我们还可以对Bean进行一些初始化操作或者后置处理，满足特定的业务需求。</p>\n<p><strong>问：在项目中，你是如何使用Spring的BeanPostProcessor扩展接口来暴露不需要验证的接口的？</strong></p>\n<p>答：在项目中，我们有一些接口是不需要进行身份验证的，如健康检查接口、日志收集接口等。为了方便地暴露这些接口，我们使用了Spring的BeanPostProcessor扩展接口。通过实现该接口，我们可以在Spring容器初始化Bean的过程中，对这些Bean进行自定义处理。具体来说，我们创建了一个自定义的BeanPostProcessor类，在该类中重写了postProcessBeforeInitialization方法。在该方法中，我们检查Bean的注解或配置信息，判断该Bean是否需要暴露为不需要验证的接口。如果是，则将其添加到一个特定的集合中。然后，在请求处理阶段，我们根据请求的URL判断是否需要验证。如果不需要验证，则直接从该集合中获取对应的Bean进行处理。通过这种方式，我们可以灵活地暴露不需要验证的接口。</p>\n<p><strong>问：使用BeanPostProcessor有哪些优势？</strong></p>\n<p>答：使用BeanPostProcessor具有以下优势：</p>\n<p><strong>l</strong> <strong>灵活性</strong>：BeanPostProcessor允许我们在Spring容器初始化Bean的过程中进行自定义处理，可以灵活地修改或增强Bean的功能。</p>\n<p><strong>l</strong> <strong>解耦</strong>：通过BeanPostProcessor，我们可以将Bean的初始化逻辑与业务逻辑分离，降低代码的耦合度，提高代码的可维护性。</p>\n<p><strong>l</strong> <strong>扩展性</strong>：BeanPostProcessor是一个扩展点，我们可以根据需要实现自己的BeanPostProcessor来处理特定的业务逻辑，实现功能的扩展。</p>\n<p><strong>问：在实现BeanPostProcessor时，你遇到了哪些挑战？又是如何解决的？</strong></p>\n<p>答：在实现BeanPostProcessor时，我们主要面临的挑战是如何准确地识别并处理需要暴露的接口。为了解决这个问题，我们定义了一套接口标识规范，并在BeanPostProcessor中根据这些标识进行特殊处理。此外，我们还对Spring的Bean生命周期进行了深入的了解和研究，确保在正确的时机进行Bean的处理。</p>\n<p><strong>三、关于双预防生成排查任务的定时任务</strong></p>\n<p><strong>问：在双预防生成排查任务的定时任务中，你是如何解决OOM问题的？</strong></p>\n<p>答：在双预防生成排查任务的定时任务中，我们确实遇到了OOM（Out of Memory）问题。这主要是由于生成数据库连接的速度比回收数据库连接线程的速度快导致的。为了解决这个问题，我们采用了单例模式来管理数据库连接池。具体来说，我们创建了一个单例的数据库连接池管理器类，该类负责创建、管理和回收数据库连接。在生成排查任务时，我们从该管理器中获取数据库连接，使用完毕后立即归还给管理器。通过这种方式，我们可以确保数据库连接的合理使用和及时回收，避免了OOM问题的发生。</p>\n<p><strong>问：除了使用单例模式外，还有哪些措施可以帮助解决OOM问题？</strong></p>\n<p>答：除了使用单例模式外，我们还可以采取以下措施来解决OOM问题：</p>\n<p><strong>l</strong> <strong>优化数据库操作</strong>：减少不必要的数据库查询和更新操作，避免产生大量的数据库连接。</p>\n<p><strong>l</strong> <strong>合理配置JVM参数</strong>：根据项目的实际情况，合理配置JVM的堆内存大小、垃圾回收策略等参数，提高JVM的性能和稳定性。</p>\n<p><strong>l</strong> <strong>使用缓存</strong>：对于频繁访问且不经常变动的数据，可以使用缓存来存储，减少对数据库的访问压力。</p>\n<p><strong>l</strong> <strong>监控和预警</strong>：使用监控工具对系统的内存使用情况进行实时监控，并设置合理的预警阈值，及时发现并解决潜在的OOM问题。</p>\n<p><strong>四、关于作业票业务中特殊字段的处理</strong></p>\n<p><strong>问：作业票业务中的九大作业票有哪些特殊字段？</strong></p>\n<p>答：作业票业务中的九大作业票各自具有不同的特殊字段，这些字段通常与作业类型、作业环境、安全要求等相关。例如，某些作业票可能需要记录作业人员的资质信息、作业设备的状态信息、作业环境的安全条件等。这些特殊字段对于作业票的管理和审批至关重要。</p>\n<p><strong>问：你是如何使用MySql8中的Json新特性来处理这些特殊字段的？</strong></p>\n<p>答：为了灵活处理这些特殊字段，我们利用了MySql8中的Json数据类型及其相关的新特性。我们将这些特殊字段存储为Json格式的数据，利用MySql8提供的Json函数进行查询和修改操作。这样，我们可以根据业务需求动态地添加、修改或删除字段，而无需修改数据库表结构。同时，Json数据类型也提供了较好的扩展性和灵活性，能够适应未来可能的业务变化。</p>\n<p> 在 MySQL 8 中引入了许多新的 JSON 相关功能，传统的关系型数据库可以使用这些功能来处理 JSON 数据。以下是一些处理特殊字段的常见操作：</p>\n<ol>\n<li><p><strong>查询 JSON 字段数据</strong>：可以使用 <code>JSON_EXTRACT()</code> 或 <code>-&gt;</code> 运算符来提取 JSON 字段中的数据。例如：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> json_data<span class=\"operator\">-</span><span class=\"operator\">&gt;</span><span class=\"string\">&#x27;$.key&#x27;</span> <span class=\"keyword\">FROM</span> table_name;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>更新 JSON 字段数据</strong>：使用 <code>JSON_SET()</code> 函数来更新 JSON 字段中的数据。例如：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">UPDATE</span> table_name <span class=\"keyword\">SET</span> json_data <span class=\"operator\">=</span> JSON_SET(json_data, <span class=\"string\">&#x27;$.key&#x27;</span>, <span class=\"string\">&#x27;new_value&#x27;</span>) <span class=\"keyword\">WHERE</span> <span class=\"keyword\">condition</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>插入 JSON 数据</strong>：通过将 JSON 数据直接插入到 JSON 字段中来插入新数据。例如：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> table_name (json_data) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;&#123;&quot;key&quot;: &quot;value&quot;&#125;&#x27;</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>查询特定条件下的 JSON 数据</strong>：可以使用 <code>JSON_CONTAINS()</code> 函数来查询满足特定条件的 JSON 数据。例如：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> table_name <span class=\"keyword\">WHERE</span> JSON_CONTAINS(json_data, <span class=\"string\">&#x27;&#123;&quot;key&quot;: &quot;value&quot;&#125;&#x27;</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>操作 JSON 数组</strong>：使用 <code>JSON_ARRAY()</code> 和 <code>JSON_OBJECT()</code> 来处理 JSON 数组。例如：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">JSON_ARRAY</span>(<span class=\"string\">&#x27;value1&#x27;</span>, <span class=\"string\">&#x27;value2&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">JSON_OBJECT</span>(<span class=\"string\">&#x27;key1&#x27;</span>, <span class=\"string\">&#x27;value1&#x27;</span>, <span class=\"string\">&#x27;key2&#x27;</span>, <span class=\"string\">&#x27;value2&#x27;</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>删除 JSON 字段中的数据</strong>：你可以使用 <code>JSON_REMOVE()</code> 函数来删除 JSON 字段中的数据。以下是一些示例：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">UPDATE</span> table_name <span class=\"keyword\">SET</span> json_data <span class=\"operator\">=</span> JSON_REMOVE(json_data, <span class=\"string\">&#x27;$.key&#x27;</span>) <span class=\"keyword\">WHERE</span> <span class=\"keyword\">condition</span>;</span><br></pre></td></tr></table></figure>\n\n<p>上面的示例中，<code>JSON_REMOVE()</code> 函数通过指定路径来删除 JSON 字段中的数据。你可以根据你的需求来调整路径和条件。</p>\n<p><strong>删除整个 JSON 字段</strong>：使用 <code>UPDATE</code> 语句来将 JSON 字段设置为 <code>NULL</code>，从而删除整个 JSON 字段的数据：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">UPDATE</span> table_name <span class=\"keyword\">SET</span> json_data <span class=\"operator\">=</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">WHERE</span> <span class=\"keyword\">condition</span>;</span><br></pre></td></tr></table></figure></li>\n</ol>\n","feature":true,"text":"一、关于数据源切换 问：在项目中，如何实现企业数据源的动态切换？ 答：为了实现企业数据源的动态切换，我们采用了Hibernate与ThreadLocal的结合。...","permalink":"/post/企业生产SaaS项目技术实现细节","photos":[],"count_time":{"symbolsCount":"5.4k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"面经","slug":"面经","count":1,"path":"api/tags/面经.json"}],"toc":"","author":{"name":"Fausto Wu","slug":"blog-author","avatar":"https://himg.bdimg.com/sys/portrait/item/pp.1.6326f07e.mlPaRS5MgyJSkED3WMXgqA?_t=1710767464259","link":"/","description":"编程优雅化。<br>Elegant programming.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"skyTakeOut项目技术要点","uid":"b101a1acd58b1556dc0f6a106802ccd2","slug":"skyTakeOut项目技术要点","date":"2024-03-25T11:52:55.000Z","updated":"2024-03-25T11:54:24.262Z","comments":true,"path":"api/articles/skyTakeOut项目技术要点.json","keywords":null,"cover":null,"text":"1. niginx使用nginx的好处: 提高访问速度 进行负载均衡：把大量的请求按照我们指定的方式均衡党的分配给集群中的每台服务器 保证后端服务安全 ngin...","permalink":"/post/skyTakeOut项目技术要点","photos":[],"count_time":{"symbolsCount":"6k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"项目","slug":"项目","count":1,"path":"api/tags/项目.json"}],"author":{"name":"Fausto Wu","slug":"blog-author","avatar":"https://himg.bdimg.com/sys/portrait/item/pp.1.6326f07e.mlPaRS5MgyJSkED3WMXgqA?_t=1710767464259","link":"/","description":"编程优雅化。<br>Elegant programming.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"JavaSE面试问题总结——答案版","uid":"531f170567168922331d8060bfe590e6","slug":"JavaSE面试问题总结——答案版","date":"2024-03-19T08:08:30.000Z","updated":"2024-03-25T11:44:33.492Z","comments":true,"path":"api/articles/JavaSE面试问题总结——答案版.json","keywords":null,"cover":null,"text":"1. 面向对象1.1 什么是面向对象编程？面向对象编程是一种程序设计思想，通过将问题抽象成对象，通过对象之间的交互和数据封装来实现程序逻辑。 1.2 Java中...","permalink":"/post/JavaSE面试问题总结——答案版","photos":[],"count_time":{"symbolsCount":"32k","symbolsTime":"29 mins."},"categories":[],"tags":[{"name":"八股","slug":"八股","count":2,"path":"api/tags/八股.json"}],"author":{"name":"Fausto Wu","slug":"blog-author","avatar":"https://himg.bdimg.com/sys/portrait/item/pp.1.6326f07e.mlPaRS5MgyJSkED3WMXgqA?_t=1710767464259","link":"/","description":"编程优雅化。<br>Elegant programming.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}