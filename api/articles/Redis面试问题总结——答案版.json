{"title":"Redis面试问题总结——答案版","uid":"55c312fa2e77afdfd966e3f29479617e","slug":"Redis面试问题总结——答案版","date":"2024-03-18T13:00:00.000Z","updated":"2024-03-24T12:39:28.821Z","comments":true,"path":"api/articles/Redis面试问题总结——答案版.json","keywords":null,"cover":null,"content":"<h1 id=\"1-常规问题\"><a href=\"#1-常规问题\" class=\"headerlink\" title=\"1. 常规问题\"></a>1. 常规问题</h1><h2 id=\"1-1-什么是Redis，为什么用Redis？\"><a href=\"#1-1-什么是Redis，为什么用Redis？\" class=\"headerlink\" title=\"1.1 什么是Redis，为什么用Redis？\"></a>1.1 什么是Redis，为什么用Redis？</h2><p>Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。</p>\n<p>• 读写性能优异：Redis能读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s （测试条件见下一节）。</p>\n<p>• 数据类型丰富：Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</p>\n<p>• 原子性：Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</p>\n<p>• 丰富的特性：Redis支持 publish&#x2F;subscribe, 通知, key 过期等特性。</p>\n<p>• 持久化：Redis支持RDB, AOF等持久化方式</p>\n<p>• 发布订阅：Redis支持发布&#x2F;订阅模式</p>\n<p>• 分布式：Redis Cluster</p>\n<h2 id=\"1-2-为什么Redis-是单线程的以及为什么这么快？\"><a href=\"#1-2-为什么Redis-是单线程的以及为什么这么快？\" class=\"headerlink\" title=\"1.2. 为什么Redis 是单线程的以及为什么这么快？\"></a>1.2. 为什么Redis 是单线程的以及为什么这么快？</h2><p>• <strong>redis完全基于内存</strong>,绝大部分请求是纯粹的内存操作,非常快速.</p>\n<p>• <strong>数据结构简单</strong>,对数据操作也简单,redis中的数据结构是专门进行设计的</p>\n<p>• <strong>采用单线程模型</strong>, 避免了不必要的上下文切换和竞争条件, 也不存在多线程或者多线程切换而消耗CPU, 不用考虑各种锁的问题, 不存在加锁, 释放锁的操作, 没有因为可能出现死锁而导致性能消耗</p>\n<p>• <strong>使用了<u>多路IO复用模型</u></strong>,<u>非阻塞IO</u></p>\n<p>• <strong>使用底层模型不同</strong>,它们之间底层实现方式及与客户端之间的通信的应用协议不一样,Redis直接构建了自己的VM机制,因为一般的系统调用系统函数的话,会浪费一定的时间去移动和请求</p>\n<h3 id=\"1-2-1-阻塞IO模型（blocking-I-O）\"><a href=\"#1-2-1-阻塞IO模型（blocking-I-O）\" class=\"headerlink\" title=\"1.2.1 阻塞IO模型（blocking I&#x2F;O）\"></a>1.2.1 阻塞IO模型（blocking I&#x2F;O）</h3><p><strong>场景描述</strong><br>        点完餐后，不知道什么时候能做好，只好坐在餐厅里面等，直到做好，然后吃完才离开。但是不知道饭能什么时候做好，只好在餐厅等，而不能去逛街，直到吃完饭才能去逛街，中间等待做饭的时间浪费掉了。这就是典型的阻塞。</p>\n<p><strong>优点：</strong></p>\n<p>能够及时返回数据，无延迟；<br>对内核开发者来说这是省事了；</p>\n<p><strong>缺点：</strong><br>对用户来说处于等待就要付出性能的代价了；</p>\n<h3 id=\"1-2-2-非阻塞IO模型（nonblocking-I-O）\"><a href=\"#1-2-2-非阻塞IO模型（nonblocking-I-O）\" class=\"headerlink\" title=\"1.2.2 非阻塞IO模型（nonblocking I&#x2F;O）\"></a>1.2.2 非阻塞IO模型（nonblocking I&#x2F;O）</h3><p>场景描述<br>        我女友不甘心白白在这等，又想去逛商场，又担心饭好了。所以我们逛一会，回来询问服务员饭好了没有，来来回回好多次，饭都还没吃都快累死了啦。这就是非阻塞。需要不断的询问，是否准备好了。</p>\n<p>同步非阻塞就是 “每隔一会儿瞄一眼进度条” 的轮询（polling）方式。所以，非阻塞 IO的特点是用户进程需要不断的主动询问kernel数据好了没有。</p>\n<p><strong>优点：</strong>能够在等待任务完成的时间里干其他活了（包括提交其他任务，也就是 “后台” 可以有多个任务在同时执行）。</p>\n<p><strong>缺点：</strong>任务完成的响应延迟增大了，因为每过一段时间才去轮询一次read操作，而任务可能在两次轮询之间的任意时间完成。这会导致整体数据吞吐量的降低。</p>\n<h3 id=\"1-2-3-IO多路复用模型（I-O-multiplexing）\"><a href=\"#1-2-3-IO多路复用模型（I-O-multiplexing）\" class=\"headerlink\" title=\"1.2.3 IO多路复用模型（I&#x2F;O multiplexing）\"></a>1.2.3 IO多路复用模型（I&#x2F;O multiplexing）</h3><p><strong>场景描述</strong><br>        与第二个方案差不多，餐厅安装了电子屏幕用来显示点餐的状态，这样我和女友逛街一会，回来就不用去询问服务员了，直接看电子屏幕就可以了。这样每个人的餐是否好了，都直接看电子屏幕就可以了，这就是典型的IO多路复用。</p>\n<p>I&#x2F;O多路复用的<strong>主要应用场景</strong>如下：</p>\n<p>服务器需要同时处理多个处于监听状态或者多个连接状态的套接字。<br>服务器需要同时处理多种网络协议的套接字。<br>在IO 多路复用模型中，对于每一个socket，一般都设置成为non-blocking，但是，整个用户的进程其实是一直被block的。只不过进程是被select这个函数block，而不是被socket IO给block。所以IO多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I&#x2F;O系统调用上。</p>\n<h2 id=\"1-3-Redis-一般有哪些使用场景？\"><a href=\"#1-3-Redis-一般有哪些使用场景？\" class=\"headerlink\" title=\"1.3. Redis 一般有哪些使用场景？\"></a>1.3. Redis 一般有哪些使用场景？</h2><p>可以结合自己的项目讲讲，比如</p>\n<p>• <strong>热点数据的缓存</strong>：缓存是Redis<strong>最常见</strong>的应用场景，之所有这么使用，主要是因为Redis读写性能优异。而且逐渐有取代**<u>memcached</u>**，成为首选服务端缓存的组件。而且，Redis内部是支持事务的，在使用时候能有效保证数据的一致性。</p>\n<p>• <strong>限时业务的运用</strong>：redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在<strong>限时的优惠活动信息</strong>、<strong>手机验证码</strong>等业务场景。</p>\n<p>• <strong>计数器相关问题</strong>：redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制<strong>一个手机号发多少条短信</strong>、<strong>一个接口一分钟限制多少请求</strong>、<strong>一个接口一天限制调用多少次</strong>等等。</p>\n<p>• <strong>分布式锁</strong>：这个主要利用redis的<strong>setnx命令</strong>进行，setnx：”set if not exists”就是如果不存在则成功设置缓存同时返回1，否则返回0 ，这个特性在集群的服务器中有所运用，定时任务可能在两台机器上都会运行，所以在定时任务中首先通过<strong>setnx</strong>设置一个<strong>lock</strong>，如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个<strong>lock</strong>加一个<strong>过期时间</strong>，比如说30分钟执行一次的定时任务，那么这个过期时间设置为<strong>小于</strong>30分钟的一个时间就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。在分布式锁的场景中，主要用在比如<strong>秒杀系统</strong>等。</p>\n<h1 id=\"2-数据类型和数据结构\"><a href=\"#2-数据类型和数据结构\" class=\"headerlink\" title=\"2. 数据类型和数据结构\"></a>2. 数据类型和数据结构</h1><h2 id=\"2-1-Redis-有哪些数据类型？\"><a href=\"#2-1-Redis-有哪些数据类型？\" class=\"headerlink\" title=\"2.1 Redis 有哪些数据类型？\"></a>2.1 Redis 有哪些数据类型？</h2><p> 5种基础数据类型，分别是：String、List、Set、Zset、Hash。</p>\n<p>结构类型结构存储的值结构的读写能力<strong>String字符串</strong>可以是字符串、整数或浮点数对整个字符串或字符串的一部分进行操作；对整数或浮点数进行自增或自减操作；<strong>List列表一个链表</strong>，链表上的每个节点都包含一个字符串对链表的两端进行push和pop操作，读取单个或多个元素；根据值查找或删除元素；<strong>Set集合</strong>包含字符串的无序集合字符串的集合，包含基础的方法有看是否存在添加、获取、删除；还包含计算交集、并集、差集等；<strong>Hash散列</strong>包含键值对的无序散列表包含方法有添加、获取、删除单个元素；<strong>Zset有序集合</strong>和散列一样，用于存储键值对字符串成员与浮点数分数之间的有序映射；元素的排列顺序由分数的大小决定；包含方法有添加、获取、删除单个元素以及根据分值范围或成员来获取元素</p>\n<p>• 三种特殊的数据类型 分别是 HyperLogLogs（基数统计）， Bitmaps (位图) 和 geospatial （地理位置) </p>\n<h2 id=\"2-2-谈谈Redis-的对象机制（redisObject-？\"><a href=\"#2-2-谈谈Redis-的对象机制（redisObject-？\" class=\"headerlink\" title=\"2.2 谈谈Redis 的对象机制（redisObject)？\"></a>2.2 谈谈Redis 的对象机制（redisObject)？</h2><p>比如说， <strong>集合类型</strong>就可以由字典和整数集合两种不同的数据结构实现， 但是， 当用户执行 ZADD 命令时， 他&#x2F;她应该<strong>不必关心</strong>集合使用的是什么编码， 只要 Redis 能按照 ZADD 命令的指示， 将新元素添加到集合就可以了。</p>\n<p>这说明, 操作数据类型的命令除了要对键的类型进行检查之外, 还需要根据数据类型的不同编码进行<strong>多态处理</strong>.</p>\n<p>为了解决以上问题, Redis 构建了自己的类型系统, 这个系统的主要功能包括:</p>\n<p>• redisObject 对象.</p>\n<p>• 基于 redisObject 对象的<strong>类型检查</strong>.</p>\n<p>• 基于 redisObject 对象的<strong>显式多态函数</strong>.</p>\n<p>• 对 redisObject 进行分配、共享和销毁的机制. </p>\n<h2 id=\"2-3-Redis-数据类型有哪些底层数据结构？\"><a href=\"#2-3-Redis-数据类型有哪些底层数据结构？\" class=\"headerlink\" title=\"2.3 Redis 数据类型有哪些底层数据结构？\"></a>2.3 Redis 数据类型有哪些底层数据结构？</h2><p>• 简单动态字符串 - sds</p>\n<p>• 压缩列表 - ZipList</p>\n<p>• 快表 - QuickList</p>\n<p>• 字典&#x2F;哈希表 - Dict</p>\n<p>• 整数集 - IntSet</p>\n<p>• 跳表 - ZSkipList</p>\n<h2 id=\"2-4-为什么要设计sds？\"><a href=\"#2-4-为什么要设计sds？\" class=\"headerlink\" title=\"2.4 为什么要设计sds？\"></a>2.4 为什么要设计<u>sds</u>？</h2><p><u><em>定义：Redis中的SDS（Simple Dynamic Strings）是一种用于表示字符串的内部数据结构。</em></u></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> len; <span class=\"comment\">/* 存储字符串的长度 */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> alloc; <span class=\"comment\">/* 已经分配的总长度 */</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">char</span> flags; <span class=\"comment\">/* 存的这个结构的类型,其中的最低3个bit用来表示header的类型,剩余5位未使用 */</span></span><br><span class=\"line\">    <span class=\"type\">char</span> buf[]; <span class=\"comment\">/* 一个c字符串,用来存储真实的字符串 */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>• 常数复杂度获取字符串长度</strong></p>\n<p>由于 len 属性的存在，我们获取 SDS 字符串的长度只需要读取 len 属性，时间复杂度为 O(1)。而对于 C 语言，获取字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。通过 strlen key 命令可以获取 key 的字符串长度。</p>\n<p><strong>• 杜绝缓冲区溢出</strong></p>\n<p>我们知道在 C 语言中使用 strcat 函数来进行两个字符串的拼接，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。而对于 SDS 数据类型，在进行字符修改的时候，会首先根据记录的 len 属性检查内存空间是否满足需求，如果不满足，会进行<u>相应的空间扩展</u>，然后在进行修改操作，所以不会出现缓冲区溢出。</p>\n<p><strong>• 减少修改字符串的内存重新分配次数</strong></p>\n<p>C语言由于不记录字符串的长度，所以如果要修改字符串，必须要重新分配内存（先释放再申请），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。</p>\n<p>而对于SDS，由于len属性和alloc属性的存在，对于修改字符串SDS实现了空间预分配和<u>惰性空间</u>释放两种策略：</p>\n<p><u><em>惰性空间，就像人具有懒惰性一样，空间的分配也可以具有懒惰性，简单说，如果Chunk在刚开始没有分配这么多空间，而是在需要的时候按需进行扩容，这种方法既节省了空间的浪费，也使得内部造成的碎片不会太多。</em></u></p>\n<ol>\n<li><p><strong>空间预分配</strong>：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少<strong>连续执行字符串增长</strong>操作所需的内存重分配次数。</p>\n</li>\n<li><p><strong>惰性空间释放</strong>：对字符串进行缩短操作时，程序不立即使用内存重新分配来回收缩短后多余的字节，而是使用 alloc 属性将这些字节的数量<strong>记录</strong>下来，等待后续使用。（当然SDS也提供了相应的API，当我们有需要时，也可以手动释放这些未使用的空间。）</p>\n</li>\n</ol>\n<p><strong>• 二进制安全</strong></p>\n<p>因为C字符串以<strong>空字符</strong>作为字符串结束的标识，而对于一些二进制文件（如<strong>图片</strong>等），<strong>内容可能包括空字符串</strong>，因此C字符串无法正确存取；而所有 SDS 的API 都是以处理二进制的方式来处理 buf 里面的元素，并且 SDS 不是以空字符串来判断是否结束，而是以 <strong>len 属性</strong>表示的长度来判断字符串是否结束。</p>\n<p><strong>• 兼容部分 C 字符串函数</strong></p>\n<p>虽然 SDS 是二进制安全的，但是一样遵从每个字符串都是<strong>以空字符串结尾的惯例</strong>，这样可以<strong>重用</strong> C 语言库&lt;string.h&gt; 中的一部分函数。 </p>\n<h2 id=\"2-5-Redis-一个字符串类型的值能存储最大容量是多少？\"><a href=\"#2-5-Redis-一个字符串类型的值能存储最大容量是多少？\" class=\"headerlink\" title=\"2.5 Redis 一个字符串类型的值能存储最大容量是多少？\"></a>2.5 Redis 一个字符串类型的值能存储最大容量是多少？</h2><p>512M</p>\n<h2 id=\"2-6-为什么会设计Stream？\"><a href=\"#2-6-为什么会设计Stream？\" class=\"headerlink\" title=\"2.6 为什么会设计Stream？\"></a>2.6 为什么会设计Stream？</h2><p>Redis引入Stream是为了支持更高级别的数据结构和操作，以满足现代应用中越来越复杂的需求。Stream是一种新型的<strong>数据结构</strong>，可以轻松地实现类似消息队列、日志引擎等功能。用过Redis做消息队列的都了解，基于Reids的消息队列实现有很多种，例如：</p>\n<p>• <u>PUB&#x2F;SUB，订阅&#x2F;发布模式</u></p>\n<p><u><em>Redis发布&#x2F;订阅（Pub&#x2F;Sub）是一种通信机制，将数据推到某个信息管道中，其他客户端可通过订阅这些管道来获取推送信息，以此用于消息的传输。由三部分组成：发布者（Publisher）、频道（Channel）、订阅者（Subscriber）。</em></u></p>\n<p>​\t但是发布订阅模式是<strong>无法持久化</strong>的，如果出现网络断开、Redis 宕机等，消息就<strong>会被丢弃</strong>；</p>\n<p>• 基于<u>List LPUSH+BRPOP</u> 或者 基于<u>Sorted-Set</u> 的实现</p>\n<ol>\n<li><em><u>使用LPUSH和BRPOP命令：LPUSH命令用于将一个或多个值插入到列表头部。BRPOP命令是RPOP的阻塞版本，它会移除并获得列表的最后一个元素，如果列表没有元素会阻塞列表直到等待时间超时或者收到一个元素。</u></em></li>\n<li><em><u>使用Sorted Set和BZPOPMAX命令：ZADD命令用于将一个或多个成员元素及其分数值加入到有序集当中。BZPOPMAX是ZPOPMAX的阻塞版本，它会移除并获取有序集合中分数最大的元素，如果有序集合为空，那么命令会阻塞，直到有元素添加到有序集合中或者指定的超时时间发生。</u></em></li>\n</ol>\n<p>​\t支持了<strong>持久化</strong>，但是<strong>不支持多播，分组消费</strong>等</p>\n<h2 id=\"2-7-Redis-Stream用在什么样场景？\"><a href=\"#2-7-Redis-Stream用在什么样场景？\" class=\"headerlink\" title=\"2.7 Redis Stream用在什么样场景？\"></a>2.7 Redis Stream用在什么样场景？</h2><p>可用<strong>作时通信</strong>等，<strong>大数据分析</strong>，<strong>异地数据备份</strong>等</p>\n<p>客户端可以平滑扩展，提高处理能力</p>\n<h2 id=\"2-8-Redis-Stream消息ID的设计是否考虑了时间回拨的问题？\"><a href=\"#2-8-Redis-Stream消息ID的设计是否考虑了时间回拨的问题？\" class=\"headerlink\" title=\"2.8 Redis Stream消息ID的设计是否考虑了时间回拨的问题？\"></a>2.8 Redis Stream消息ID的设计是否考虑了时间回拨的问题？</h2><p>Redis生成的消息ID，由两部分组成:<strong>时间戳-序号</strong>。时间戳是<strong>毫秒级</strong>单位，是生成消息的Redis<strong>服务器时间</strong>，它是个<strong>64位整型</strong>（int64）。序号是在这个<strong>毫秒时间点内的消息序号</strong>，它也是个<strong>64位整型</strong>。</p>\n<p>可以通过multi批处理，来验证序号的递增：</p>\n<p>由于一个redis命令的执行很快，所以可以看到在同一时间戳内，是<strong>通过序号递增</strong>来表示消息的。</p>\n<p>为了保证消息是有序的，因此Redis生成的ID是单调递增有序的。由于ID中包含时间戳部分，为了避免服务器时间错误而带来的问题（例如服务器时间延后了），Redis的每个Stream类型数据都维护一个latest_generated_id属性，用于记录最后一个消息的ID。若发现当前<strong>时间戳退后</strong>（小于latest_generated_id所记录的），则采用<strong>时间戳不变而序号递增</strong>的方案来作为新消息ID（这也是序号为什么使用int64的原因，保证有足够多的的序号），从而保证<strong>ID的单调递增</strong>性质。</p>\n<p>强烈建议使用Redis的方案生成消息ID，因为这种时间戳+序号的单调递增的ID方案，几乎可以满足你全部的需求。但同时，记住ID是<strong>支持自定义</strong>的，别忘了！ </p>\n<h2 id=\"2-9-Redis-Stream消费者崩溃带来的会不会消息丢失问题\"><a href=\"#2-9-Redis-Stream消费者崩溃带来的会不会消息丢失问题\" class=\"headerlink\" title=\"2.9 Redis Stream消费者崩溃带来的会不会消息丢失问题?\"></a>2.9 Redis Stream消费者崩溃带来的会不会消息丢失问题?</h2><p>为了解决组内消息读取但处理期间消费者崩溃带来的消息丢失问题，STREAM 设计了 <strong>Pending 列表</strong>，用于记录<strong>读取但并未处理完毕</strong>的消息。<strong>命令XPENDIING</strong> 用来获消费组或消费内消费者的未处理完毕的消息。</p>\n<p>每个Pending的消息有4个属性：</p>\n<p>• <strong>消息ID</strong></p>\n<p>• <strong>所属消费者</strong></p>\n<p>• IDLE，<strong>已读取时长</strong></p>\n<p>• delivery counter，<strong>消息被读取次数</strong></p>\n<p>若消息被记录在Pending列表中，说明全部读到的消息都没有处理，仅仅是读取了。那如何表示消费者处理完毕了消息呢？使用<strong>命令 XACK</strong> 完成告知消息处理完成，演示如下：</p>\n<p>有了这样一个Pending机制，就意味着在某个消费者读取消息但未处理后，<strong>消息是不会丢失的</strong>。等待消费者再次上线后，可以读取该Pending列表，就可以继续处理该消息了，保证消息的<strong>有序</strong>和<strong>不丢失</strong>。</p>\n<h2 id=\"2-10-Redis-Steam-坏消息问题，死信问题\"><a href=\"#2-10-Redis-Steam-坏消息问题，死信问题\" class=\"headerlink\" title=\"2.10 Redis Steam 坏消息问题，死信问题?\"></a>2.10 Redis Steam 坏消息问题，死信问题?</h2><p>正如上面所说，如果某个消息，不能被消费者处理，也就是不能被XACK，这是要长时间处于Pending列表中，即使被反复的转移给各个消费者也是如此。此时该消息的delivery counter就会累加（上一节的例子可以看到），当累加到某个我们<strong>预设的临界值</strong>时，我们就认为是坏消息（也叫死信，DeadLetter，无法投递的消息），由于有了判定条件，我们将坏消息处理掉即可，<strong>删除即可</strong>。删除一个消息，使用XDEL语法。</p>\n<h1 id=\"3-持久化和内存\"><a href=\"#3-持久化和内存\" class=\"headerlink\" title=\"3. 持久化和内存\"></a>3. 持久化和内存</h1><h2 id=\"3-1-Redis-的持久化机制是什么？各自的优缺点？一般怎么用？\"><a href=\"#3-1-Redis-的持久化机制是什么？各自的优缺点？一般怎么用？\" class=\"headerlink\" title=\"3.1 Redis 的持久化机制是什么？各自的优缺点？一般怎么用？\"></a>3.1 Redis 的持久化机制是什么？各自的优缺点？一般怎么用？</h2><ol>\n<li><p><strong>RDB持久化</strong>是把当前进程数据生成<strong>快照</strong>保存到<strong>磁盘</strong>上的过程; 针对RDB不适合实时持久化的问题，Redis提供了<strong>AOF持久化方式</strong>来解决.</p>\n</li>\n<li><p>AOF是<strong>“写后”日志</strong>，Redis先执行命令，把数据写入<strong>内存</strong>，然后才记录日志。日志里记录的是Redis收到的每一条命令，这些命令是以<strong>文本形式</strong>保存。</p>\n</li>\n<li><p>Redis 4.0 中提出了一个<strong>混合</strong>使用 <strong>AOF 日志</strong>和<strong>内存快照</strong>的方法。简单来说，内存快照以<strong>一定的频率</strong>执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。</p>\n</li>\n</ol>\n<p>这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。</p>\n<p>这个方法既能享受到 RDB 文件快速恢复的好处，又能享受到 AOF 只记录操作命令的简单优势, 实际环境中用的很多。 </p>\n<h2 id=\"3-2-RDB-触发方式\"><a href=\"#3-2-RDB-触发方式\" class=\"headerlink\" title=\"3.2 RDB 触发方式?\"></a>3.2 RDB 触发方式?</h2><p>触发rdb持久化的方式有2种，分别是<strong>手动触发</strong>和<strong>自动触发</strong>。</p>\n<h3 id=\"3-2-1-手动触发\"><a href=\"#3-2-1-手动触发\" class=\"headerlink\" title=\"3.2.1 手动触发\"></a>3.2.1 手动触发</h3><p>• <strong>save命令</strong>：<strong>阻塞当前Redis服务器</strong>，直到RDB过程完成为止，对于内存 比较大的实例会造成长时间阻塞，线上环境不建议使用</p>\n<p>• <strong>bgsave命令</strong>：Redis进程执行fork操作创建子进程，RDB持久化过程由<strong>子进程</strong>负责，完成后自动结束。<strong>阻塞只发生在fork阶段</strong>，一般时间很短 </p>\n<h3 id=\"3-2-2-自动触发\"><a href=\"#3-2-2-自动触发\" class=\"headerlink\" title=\"3.2.2 自动触发\"></a>3.2.2 自动触发</h3><p>• redis.conf中配置<strong>save m n</strong>，即在<strong>m秒内有n次修改时</strong>，自动触发bgsave生成rdb文件；</p>\n<p>• <strong>主从复制时</strong>，从节点要从主节点进行<strong>全量复制</strong>时也会触发bgsave操作，生成当时的快照发送到从节点；</p>\n<p>• <strong>执行debug reload命令</strong>重新加载redis时也会触发bgsave操作；</p>\n<p>• 默认情况下<strong>执行shutdown命令</strong>时，如果<strong>没有开启aof持久化</strong>，那么也会触发bgsave操作；</p>\n<h2 id=\"3-3-那么如何保证数据一致性呢？\"><a href=\"#3-3-那么如何保证数据一致性呢？\" class=\"headerlink\" title=\"3.3 那么如何保证数据一致性呢？\"></a>3.3 那么如何保证数据一致性呢？</h2><p>RDB由于生产环境中我们为Redis开辟的内存区域都比较大（例如6GB），那么将内存中的数据同步到硬盘的过程可能就会持续比较长的时间，而实际情况是这段时间Redis服务一般都会收到数据写操作请求。那么如何保证数据一致性呢？</p>\n<p>RDB中的核心思路是Copy-on-Write，来保证在进行快照操作的这段时间，需要压缩写入磁盘上的数据在内存中不会发生变化。在正常的快照操作中，一方面Redis主进程会<strong>fork一个新的快照进程</strong>专门来做这个事情，这样保证了Redis服务不会停止对客户端包括写请求在内的任何响应。另一方面这段时间发生的数据变化会以<strong>副本</strong>的方式存放在另一个<strong>新的内存区域</strong>，待快照操作结束后才会<strong>同步</strong>到原来的内存区域。</p>\n<p>举个例子：如果主线程对这些数据也都是读操作，那么，主线程和 bgsave 子进程相互不影响。但是，如果主线程要修改一块数据，那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。 </p>\n<h2 id=\"3-4-在进行RDB快照操作的这段时间，如果发生服务崩溃怎么办？\"><a href=\"#3-4-在进行RDB快照操作的这段时间，如果发生服务崩溃怎么办？\" class=\"headerlink\" title=\"3.4 在进行RDB快照操作的这段时间，如果发生服务崩溃怎么办？\"></a>3.4 在进行RDB快照操作的这段时间，如果发生服务崩溃怎么办？</h2><p>很简单，在没有将数据全部写入到磁盘前，这次快照操作都不算成功。如果出现了服务崩溃的情况，将<strong>以上一次完整的RDB快照文件</strong>作为恢复内存数据的参考。也就是说，在快照操作过程中不能影响上一次的备份数据。Redis服务会在磁盘上创建一个<strong>临时文件</strong>进行数据操作，待操作成功后才会用这个临时文件替换掉上一次的备份。</p>\n<h2 id=\"3-5-可以每秒做一次RDB快照吗？\"><a href=\"#3-5-可以每秒做一次RDB快照吗？\" class=\"headerlink\" title=\"3.5 可以每秒做一次RDB快照吗？\"></a>3.5 可以每秒做一次RDB快照吗？</h2><p>对于快照来说，所谓“<strong>连拍</strong>”就是指连续地做快照。这样一来，快照的间隔时间变得很短，即使某一时刻发生宕机了，因为上一时刻快照刚执行，丢失的数据也不会太多。但是，这其中的<strong>快照间隔时间</strong>就很关键了。</p>\n<p>如下图所示，我们先在 T0 时刻做了一次快照，然后又在 T0+t 时刻做了一次快照，在这期间，数据块 5 和 9 被修改了。如果在 t 这段时间内，机器宕机了，那么，只能按照 T0 时刻的快照进行恢复。此时，数据块 5 和 9 的修改值因为没有快照记录，就无法恢复了。</p>\n<p>所以，要想尽可能恢复数据，t 值就要尽可能小，t 越小，就越像“连拍”。那么，t 值可以小到什么程度呢，比如说是不是可以每秒做一次快照？毕竟，每次快照都是由 bgsave 子进程在后台执行，也不会阻塞主线程。</p>\n<p>这种想法其实是错误的。虽然 bgsave 执行时不阻塞主线程，但是，如果频繁地执行全量快照，也会带来两方面的开销：</p>\n<p>• 一方面，频繁将全量数据写入磁盘，会带来很大的<strong>磁盘压力</strong>，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。</p>\n<p>• 另一方面，bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，<strong>fork 这个创建过程本身会阻塞主线程</strong>，而且<strong>主线程的内存越大，阻塞时间越长</strong>。如果频繁 fork 出 bgsave 子进程，这就会频繁阻塞主线程了。</p>\n<p>那么，有什么其他好方法吗？此时，我们可以做<strong>增量快照</strong>，就是指做了一次全量快照后，后续的快照只对<strong>修改的数据</strong>进行快照记录，这样可以避免每次全量快照的开销。这个比较好理解。</p>\n<p>但是它需要我们使用额外的元数据信息去记录哪些数据被修改了，这会带来<strong>额外的空间开销问题</strong>。那么，还有什么方法既能利用 RDB 的快速恢复，又能以较小的开销做到尽量少丢数据呢？**RDB和AOF的混合方式(Redis4.0)**。</p>\n<h2 id=\"3-6-AOF是写前日志还是写后日志？\"><a href=\"#3-6-AOF是写前日志还是写后日志？\" class=\"headerlink\" title=\"3.6 AOF是写前日志还是写后日志？\"></a>3.6 AOF是写前日志还是写后日志？</h2><p>AOF日志采用写后日志，即先写内存，后写日志。</p>\n<h3 id=\"3-6-1-为什么采用写后日志？\"><a href=\"#3-6-1-为什么采用写后日志？\" class=\"headerlink\" title=\"3.6.1 为什么采用写后日志？\"></a>3.6.1 为什么采用写后日志？</h3><p>Redis要求高性能，采用写日志有两方面好处：</p>\n<p>• <strong>避免额外的检查开销</strong>：Redis 在向 AOF 里面记录日志的时候，并<strong>不会</strong>先去对这些命令进行<strong>语法检查</strong>。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就<strong>可能会出错</strong>。</p>\n<p>• <strong>不会阻塞当前的写操作</strong></p>\n<p>但这种方式存在潜在风险：</p>\n<p>• 如果命令执行完成，写日志<strong>之前</strong>宕机了，<strong>会丢失数据</strong>。</p>\n<p>• 主线程写<strong>磁盘压力大</strong>，导致写盘慢，<strong>阻塞后续操作</strong>。 </p>\n<h2 id=\"3-7-如何实现AOF的？\"><a href=\"#3-7-如何实现AOF的？\" class=\"headerlink\" title=\"3.7 如何实现AOF的？\"></a>3.7 如何实现AOF的？</h2><p>AOF日志记录Redis的每个写命令，步骤分为：<strong>命令追加（append）、文件写入（write）和文件同步（sync）</strong>。</p>\n<p>• 命令追加 当AOF持久化功能打开了，服务器在执行完一个写命令之后，会以协议格式将<strong>被执行的写命令</strong>追加到服务器的 <strong>aof_buf 缓冲区</strong>。</p>\n<p>• 文件写入和同步 关于何时将 <strong>aof_buf 缓冲区</strong>的内容写入<strong>AOF文件</strong>中，Redis提供了<strong>三种写回策略</strong>：</p>\n<ol>\n<li><p><strong>Always</strong>，同步写回：每个写命令执行完，<strong>立马同步</strong>地将日志写回磁盘；</p>\n</li>\n<li><p><strong>Everysec</strong>，每秒写回：每个写命令执行完，只是<strong>先</strong>把日志写到AOF文件的内存缓冲区，<strong>每隔一秒</strong>把缓冲区中的内容写入磁盘；</p>\n</li>\n<li><p><strong>No</strong>，操作系统控制的写回：每个写命令执行完，只是<strong>先</strong>把日志写到AOF文件的内存缓冲区，<strong>由操作系统决定</strong>何时将缓冲区内容写回磁盘。</p>\n</li>\n</ol>\n<h2 id=\"3-8-三种写回策略的优缺点\"><a href=\"#3-8-三种写回策略的优缺点\" class=\"headerlink\" title=\"3.8 三种写回策略的优缺点\"></a>3.8 三种写回策略的优缺点</h2><p>上面的三种写回策略体现了一个重要原则：<strong>trade-off</strong>，<strong>取舍</strong>，指在<strong>性能</strong>和<strong>可靠性</strong>保证之间做取舍。</p>\n<p>关于AOF的同步策略是涉及到<strong>操作系统的</strong> <strong>write 函数</strong>和 <strong>fsync 函数</strong>的，在《Redis设计与实现》中是这样说明的</p>\n<p>为了提高文件写入效率，在现代操作系统中，当用户调用<strong>write函数</strong>，将一些数据写入文件时，操作系统通常会将数据暂存到一个内存缓冲区里，当缓冲区的空间被填满或超过了指定时限后，才真正将缓冲区的数据写入到磁盘里。</p>\n<p>这样的操作虽然提高了效率，但也为数据写入带来了<strong>安全问题</strong>：如果计算机停机，内存缓冲区中的数据会丢失。为此，系统提供了<strong>fsync</strong>、<strong>fdatasync同步函数</strong>，可以<strong>强制</strong>操作系统<strong>立刻</strong>将缓冲区中的数据写入到硬盘里，从而确保写入数据的安全性。</p>\n<h2 id=\"3-9-什么是AOF重写？\"><a href=\"#3-9-什么是AOF重写？\" class=\"headerlink\" title=\"3.9 什么是AOF重写？\"></a>3.9 什么是AOF重写？</h2><p>Redis通过创建一个<strong>新的</strong>AOF文件来替换<strong>现有的</strong>AOF，新旧两个AOF文件保存的<strong>数据相同</strong>，但新AOF文件<strong>没有了冗余命令</strong>。</p>\n<h2 id=\"3-10-AOF重写会阻塞吗？\"><a href=\"#3-10-AOF重写会阻塞吗？\" class=\"headerlink\" title=\"3.10 AOF重写会阻塞吗？\"></a>3.10 AOF重写会阻塞吗？</h2><p>AOF重写过程是由<strong>后台进程bgrewriteaof</strong>来完成的。主线程fork出后台的bgrewriteaof子进程，fork会把主线程的内存<strong>拷贝</strong>一份给bgrewriteaof子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof子进程就可以在不影响主线程的情况下，<strong>逐一</strong>把拷贝的数据写成操作，记入重写日志。</p>\n<p>所以aof在重写时，在fork进程时是<strong>会阻塞</strong>住主线程的</p>\n<h2 id=\"3-11-AOF日志何时会重写？\"><a href=\"#3-11-AOF日志何时会重写？\" class=\"headerlink\" title=\"3.11 AOF日志何时会重写？\"></a>3.11 AOF日志何时会重写？</h2><p>有两个配置项控制AOF重写的触发：</p>\n<p>auto-aof-rewrite-min-size:表示运行AOF重写时<strong>文件的最小大小</strong>，默认为64MB。</p>\n<p>auto-aof-rewrite-percentage:这个值的计算方式是，当前aof文件大小和上一次重写后aof文件大小的差值，再除以上一次重写后aof文件大小。也就是当前aof文件比上一次重写后aof文件的<strong>增量大小</strong>，和上一次重写后aof<strong>文件大小</strong>的<strong>比值</strong>。</p>\n<h2 id=\"3-12-AOF重写日志时，有新数据写入咋整？\"><a href=\"#3-12-AOF重写日志时，有新数据写入咋整？\" class=\"headerlink\" title=\"3.12 AOF重写日志时，有新数据写入咋整？\"></a>3.12 AOF重写日志时，有新数据写入咋整？</h2><p>重写过程总结为：“<strong>一个拷贝，两处日志</strong>”。在fork出子进程时的拷贝，以及在重写时，如果有新数据写入，主线程就会将命令记录到<strong>两个</strong>aof日志内存缓冲区中。如果AOF写回策略配置的是always，则直接将命令写回<strong>旧的日志文件</strong>，并且保存一份命令至<strong>AOF重写缓冲区</strong>，这些操作对新的日志文件是不存在影响的。（旧的日志文件：主线程使用的日志文件，新的日志文件：bgrewriteaof进程使用的日志文件）</p>\n<p>而在bgrewriteaof子进程完成会日志文件的重写操作后，会<strong>提示</strong>主线程已经完成重写操作，主线程会将AOF重写缓冲中的命令<strong>追加</strong>到新的日志文件后面。这时候在高并发的情况下，AOF重写缓冲区积累可能会很大，这样就会造成阻塞，Redis后来通过Linux管道技术让aof重写期间就能同时进行回放，这样aof重写结束后只需回放少量剩余的数据即可。</p>\n<p>最后通过<strong>修改文件名</strong>的方式，保证文件切换的<strong>原子性</strong>。</p>\n<p>在AOF重写日志期间发生宕机的话，因为日志文件还没切换，所以恢复数据时，用的还是旧的日志文件。</p>\n<h2 id=\"3-13-主线程fork出子进程的是如何复制内存数据的？\"><a href=\"#3-13-主线程fork出子进程的是如何复制内存数据的？\" class=\"headerlink\" title=\"3.13 主线程fork出子进程的是如何复制内存数据的？\"></a>3.13 主线程fork出子进程的是如何复制内存数据的？</h2><p>fork采用操作系统提供的写时复制（copy on write）机制，就是为了避免一次性拷贝大量内存数据给子进程造成阻塞。fork子进程时，子进程时会拷贝<strong>父进程的页表</strong>，即虚实映射关系（虚拟内存和物理内存的映射索引表），而不会拷贝物理内存。这个拷贝会消耗大量cpu资源，并且拷贝完成前会阻塞主线程，阻塞时间取决于内存中的数据量，数据量越大，则内存页表越大。拷贝完成后，<strong>父子进程使用相同的内存地址空间</strong>。但主进程是可以有数据写入的，这时候就会拷贝<strong>物理内存</strong>中的数据。 </p>\n<h2 id=\"3-14-在重写日志整个过程时，主线程有哪些地方会被阻塞？\"><a href=\"#3-14-在重写日志整个过程时，主线程有哪些地方会被阻塞？\" class=\"headerlink\" title=\"3.14 在重写日志整个过程时，主线程有哪些地方会被阻塞？\"></a>3.14 在重写日志整个过程时，主线程有哪些地方会被阻塞？</h2><ol>\n<li><p><strong>fork子进程时</strong>，需要<strong>拷贝虚拟页表</strong>，会对主线程阻塞。</p>\n</li>\n<li><p><strong>主进程有bigkey写入时</strong>，操作系统会创建页面的副本，并拷贝原有的数据，会对主线程阻塞。</p>\n</li>\n<li><p>子进程重写日志完成后，主进程<strong>追加aof重写缓冲区时</strong>可能会对主线程阻塞。</p>\n</li>\n</ol>\n<h2 id=\"3-15-为什么AOF重写不复用原AOF日志？\"><a href=\"#3-15-为什么AOF重写不复用原AOF日志？\" class=\"headerlink\" title=\"3.15 为什么AOF重写不复用原AOF日志？\"></a>3.15 为什么AOF重写不复用原AOF日志？</h2><p>两方面原因：</p>\n<ol>\n<li><p>父子进程写同一个文件会产生<strong>竞争问题</strong>，影响父进程的性能。</p>\n</li>\n<li><p>如果AOF重写过程中失败了，相当于<strong>污染</strong>了原本的AOF文件，无法做恢复数据使用。</p>\n</li>\n</ol>\n<h2 id=\"3-16-Redis-过期键的删除策略有哪些\"><a href=\"#3-16-Redis-过期键的删除策略有哪些\" class=\"headerlink\" title=\"3.16 Redis 过期键的删除策略有哪些?\"></a>3.16 Redis 过期键的删除策略有哪些?</h2><p>在单机版Redis中，存在两种删除策略：</p>\n<p>• <strong>惰性删除</strong>：服务器<strong>不会主动删除</strong>数据，只有当客户端<strong>查询某个数据时</strong>，服务器<strong>判断</strong>该数据是否过期，如果过期则删除。</p>\n<p>• <strong>定期删除</strong>：服务器执行<strong>定时任务删除过期数据</strong>，但是考虑到内存和CPU的折中（删除会释放内存，但是频繁的删除操作对CPU不友好），该删除的频率和执行时间都受到了限制。</p>\n<p>在<strong>主从复制</strong>场景下，为了主从节点的数据一致性，<strong>从节点不会主动删除数据</strong>，而是由主节点控制从节点中过期数据的删除。由于<strong>主节点的惰性删除和定期删除策略</strong>，都不能保证主节点及时对过期数据执行删除操作，因此，当客户端通过Redis从节点读取数据时，<strong>很容易读取到已经过期的数据</strong>。</p>\n<p>Redis 3.2中，从节点在读取数据时，<strong>增加</strong>了对数据是否过期的<strong>判断</strong>：如果该数据已过期，则不返回给客户端；将Redis升级到3.2可以解决数据过期问题。</p>\n<h2 id=\"3-17-Redis-内存淘汰算法有哪些\"><a href=\"#3-17-Redis-内存淘汰算法有哪些\" class=\"headerlink\" title=\"3.17 Redis 内存淘汰算法有哪些?\"></a>3.17 Redis 内存淘汰算法有哪些?</h2><p>Redis共支持<strong>八种</strong>淘汰策略，分别是noeviction、volatile-random、volatile-ttl、volatile-lru、volatile-lfu、allkeys-lru、allkeys-random 和 allkeys-lfu 策略。</p>\n<p>怎么理解呢？主要看分三类看：</p>\n<h3 id=\"3-17-1-不淘汰\"><a href=\"#3-17-1-不淘汰\" class=\"headerlink\" title=\"3.17.1 不淘汰\"></a>3.17.1 不淘汰</h3><p>• noeviction （v4.0后默认的）</p>\n<h3 id=\"3-17-2-对设置了过期时间的数据中进行淘汰\"><a href=\"#3-17-2-对设置了过期时间的数据中进行淘汰\" class=\"headerlink\" title=\"3.17.2 对设置了过期时间的数据中进行淘汰\"></a>3.17.2 对设置了过期时间的数据中进行淘汰</h3><p>• 随机：volatile-random</p>\n<p>• ttl：volatile-ttl</p>\n<p>• lru：volatile-lru</p>\n<p>• lfu：volatile-lfu</p>\n<h3 id=\"3-17-3-全部数据进行淘汰\"><a href=\"#3-17-3-全部数据进行淘汰\" class=\"headerlink\" title=\"3.17.3 全部数据进行淘汰\"></a>3.17.3 全部数据进行淘汰</h3><p>• 随机：allkeys-random</p>\n<p>• lru：allkeys-lru</p>\n<p>• lfu：allkeys-lfu</p>\n<p><strong>LRU算法</strong>：LRU 算法的全称是 Least Recently Used，按照最近最少使用的原则来筛选数据。这种模式下会使用 LRU 算法筛选设置了过期时间的键值对。</p>\n<p><strong>Redis优化的LRU算法实现</strong>：Redis会记录每个数据的<strong>最近一次被访问的时间戳</strong>。在Redis在决定淘汰的数据时，第一次会随机选出 N 个数据，把它们作为一个候选集合。接下来，Redis 会比较这 N 个数据的 lru 字段，把 <strong>lru 字段值最小</strong>的数据从缓存中淘汰出去。通过随机读取待删除集合，可以让Redis不用维护一个巨大的链表，也不用操作链表，进而提升性能。</p>\n<p><strong>LFU 算法</strong>：LFU 缓存策略是在 LRU 策略基础上，为每个数据增加了一个计数器，来统计这个数据的访问次数。当使用 LFU 策略筛选淘汰数据时，首先会根据数据的访问次数进行筛选，把<strong>访问次数最低的数据</strong>淘汰出缓存。如果两个数据的访问次数<strong>相同</strong>，LFU 策略再比较这两个数据的<strong>访问时效性</strong>，把距离上一次访问时间更久的数据淘汰出缓存。</p>\n<p><strong>Redis的LFU算法实现</strong>：当 LFU 策略筛选数据时，Redis 会在候选集合中，根据数据 <strong>lru 字段的后 8bit</strong> 选择访问次数最少的数据进行淘汰。当访问次数相同时，再根据 <strong>lru 字段的前 16bit</strong> 值大小，选择访问时间最久远的数据进行淘汰。</p>\n<p>Redis 只使用了 8bit 记录数据的访问次数，而 8bit 记录的最大值是 255，这样在访问快速的情况下，如果每次被访问就将访问次数加一，很快某条数据就达到最大值255，可能很多数据都是255，那么退化成LRU算法了。所以Redis为了解决这个问题，实现了一个更优的计数规则，并可以通过配置项，来控制计数器增加的速度。</p>\n<h2 id=\"3-18-Redis的内存用完了会发生什么？\"><a href=\"#3-18-Redis的内存用完了会发生什么？\" class=\"headerlink\" title=\"3.18 Redis的内存用完了会发生什么？\"></a>3.18 Redis的内存用完了会发生什么？</h2><p>如果达到设置的上限，Redis的<strong>写命令</strong>会返回错误信息（但是<strong>读命令</strong>还可以正常返回。）或者你可以配置<strong>内存淘汰机制</strong>，当Redis达到内存上限时会<strong>冲刷掉旧的内容</strong>。 </p>\n<h2 id=\"3-19-Redis如何做内存优化？\"><a href=\"#3-19-Redis如何做内存优化？\" class=\"headerlink\" title=\"3.19 Redis如何做内存优化？\"></a>3.19 Redis如何做内存优化？</h2><ol>\n<li><strong>缩减键值对象</strong>: 缩减键（key）和值（value）的长度，</li>\n</ol>\n<p><strong>key长度</strong>：如在设计键时，在完整描述业务情况下，键值越短越好。</p>\n<p><strong>value长度</strong>：值对象缩减比较复杂，常见需求是把业务对象序列化成二进制数组放入Redis。首先应该在业务上精简业务对象，去掉不必要的属性避免存储无效数据。其次在序列化工具选择上，应该选择更高效的序列化工具来降低字节数组大小。以JAVA为例，内置的序列化方式无论从速度还是压缩比都不尽如人意，这时可以选择更高效的序列化工具，如: protostuff，kryo等，下图是JAVA常见序列化工具空间压缩对比。</p>\n<ol start=\"2\">\n<li><strong>共享对象池</strong></li>\n</ol>\n<p>对象共享池指Redis内部维护[0-9999]的整数对象池。创建大量的整数类型redisObject存在内存开销，每个redisObject内部结构至少占16字节，甚至超过了整数自身空间消耗。所以Redis内存维护一个[0-9999]的整数对象池，用于节约内存。 除了整数值对象，其他类型如list,hash,set,zset内部元素也可以使用整数对象池。因此开发中在满足需求的前提下，尽量使用整数对象以节省内存。</p>\n<ol start=\"3\">\n<li><p>字符串优化</p>\n</li>\n<li><p>编码优化</p>\n</li>\n<li><p>控制key的数量</p>\n</li>\n</ol>\n<h2 id=\"3-20-Redis-key-的过期时间和永久有效分别怎么设置？\"><a href=\"#3-20-Redis-key-的过期时间和永久有效分别怎么设置？\" class=\"headerlink\" title=\"3.20 Redis key 的过期时间和永久有效分别怎么设置？\"></a>3.20 Redis key 的过期时间和永久有效分别怎么设置？</h2><p><strong>EXPIRE</strong> 和 <strong>PERSIST</strong> 命令</p>\n<h2 id=\"3-21-Redis-中的管道有什么用？\"><a href=\"#3-21-Redis-中的管道有什么用？\" class=\"headerlink\" title=\"3.21 Redis 中的管道有什么用？\"></a>3.21 Redis 中的管道有什么用？</h2><p>一次请求&#x2F;响应服务器能实现处理新的请求即使旧的请求还未被响应，这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。（类似于<strong>消息队列</strong>）</p>\n<p>这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多 POP3 协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。</p>\n","text":"1. 常规问题1.1 什么是Redis，为什么用Redis？Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列...","permalink":"/post/Redis面试问题总结——答案版","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"12 mins."},"categories":[],"tags":[{"name":"八股","slug":"八股","count":3,"path":"api/tags/八股.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E5%B8%B8%E8%A7%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">1. 常规问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E4%BB%80%E4%B9%88%E6%98%AFRedis%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8Redis%EF%BC%9F\"><span class=\"toc-text\">1.1 什么是Redis，为什么用Redis？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-%E4%B8%BA%E4%BB%80%E4%B9%88Redis-%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BB%A5%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB%EF%BC%9F\"><span class=\"toc-text\">1.2. 为什么Redis 是单线程的以及为什么这么快？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-1-%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B%EF%BC%88blocking-I-O%EF%BC%89\"><span class=\"toc-text\">1.2.1 阻塞IO模型（blocking I&#x2F;O）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-2-%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B%EF%BC%88nonblocking-I-O%EF%BC%89\"><span class=\"toc-text\">1.2.2 非阻塞IO模型（nonblocking I&#x2F;O）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-3-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B%EF%BC%88I-O-multiplexing%EF%BC%89\"><span class=\"toc-text\">1.2.3 IO多路复用模型（I&#x2F;O multiplexing）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-Redis-%E4%B8%80%E8%88%AC%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F\"><span class=\"toc-text\">1.3. Redis 一般有哪些使用场景？</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">2. 数据类型和数据结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-Redis-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F\"><span class=\"toc-text\">2.1 Redis 有哪些数据类型？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E8%B0%88%E8%B0%88Redis-%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%88redisObject-%EF%BC%9F\"><span class=\"toc-text\">2.2 谈谈Redis 的对象机制（redisObject)？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-3-Redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F\"><span class=\"toc-text\">2.3 Redis 数据类型有哪些底层数据结构？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-4-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1sds%EF%BC%9F\"><span class=\"toc-text\">2.4 为什么要设计sds？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-5-Redis-%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E8%83%BD%E5%AD%98%E5%82%A8%E6%9C%80%E5%A4%A7%E5%AE%B9%E9%87%8F%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F\"><span class=\"toc-text\">2.5 Redis 一个字符串类型的值能存储最大容量是多少？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-6-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%AE%BE%E8%AE%A1Stream%EF%BC%9F\"><span class=\"toc-text\">2.6 为什么会设计Stream？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-7-Redis-Stream%E7%94%A8%E5%9C%A8%E4%BB%80%E4%B9%88%E6%A0%B7%E5%9C%BA%E6%99%AF%EF%BC%9F\"><span class=\"toc-text\">2.7 Redis Stream用在什么样场景？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-8-Redis-Stream%E6%B6%88%E6%81%AFID%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%98%AF%E5%90%A6%E8%80%83%E8%99%91%E4%BA%86%E6%97%B6%E9%97%B4%E5%9B%9E%E6%8B%A8%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F\"><span class=\"toc-text\">2.8 Redis Stream消息ID的设计是否考虑了时间回拨的问题？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-9-Redis-Stream%E6%B6%88%E8%B4%B9%E8%80%85%E5%B4%A9%E6%BA%83%E5%B8%A6%E6%9D%A5%E7%9A%84%E4%BC%9A%E4%B8%8D%E4%BC%9A%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">2.9 Redis Stream消费者崩溃带来的会不会消息丢失问题?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-10-Redis-Steam-%E5%9D%8F%E6%B6%88%E6%81%AF%E9%97%AE%E9%A2%98%EF%BC%8C%E6%AD%BB%E4%BF%A1%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">2.10 Redis Steam 坏消息问题，死信问题?</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-%E6%8C%81%E4%B9%85%E5%8C%96%E5%92%8C%E5%86%85%E5%AD%98\"><span class=\"toc-text\">3. 持久化和内存</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-Redis-%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%90%84%E8%87%AA%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F%E4%B8%80%E8%88%AC%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%9F\"><span class=\"toc-text\">3.1 Redis 的持久化机制是什么？各自的优缺点？一般怎么用？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-RDB-%E8%A7%A6%E5%8F%91%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">3.2 RDB 触发方式?</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-1-%E6%89%8B%E5%8A%A8%E8%A7%A6%E5%8F%91\"><span class=\"toc-text\">3.2.1 手动触发</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-2-%E8%87%AA%E5%8A%A8%E8%A7%A6%E5%8F%91\"><span class=\"toc-text\">3.2.2 自动触发</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-3-%E9%82%A3%E4%B9%88%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E5%91%A2%EF%BC%9F\"><span class=\"toc-text\">3.3 那么如何保证数据一致性呢？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-4-%E5%9C%A8%E8%BF%9B%E8%A1%8CRDB%E5%BF%AB%E7%85%A7%E6%93%8D%E4%BD%9C%E7%9A%84%E8%BF%99%E6%AE%B5%E6%97%B6%E9%97%B4%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%8F%91%E7%94%9F%E6%9C%8D%E5%8A%A1%E5%B4%A9%E6%BA%83%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F\"><span class=\"toc-text\">3.4 在进行RDB快照操作的这段时间，如果发生服务崩溃怎么办？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-5-%E5%8F%AF%E4%BB%A5%E6%AF%8F%E7%A7%92%E5%81%9A%E4%B8%80%E6%AC%A1RDB%E5%BF%AB%E7%85%A7%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">3.5 可以每秒做一次RDB快照吗？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-6-AOF%E6%98%AF%E5%86%99%E5%89%8D%E6%97%A5%E5%BF%97%E8%BF%98%E6%98%AF%E5%86%99%E5%90%8E%E6%97%A5%E5%BF%97%EF%BC%9F\"><span class=\"toc-text\">3.6 AOF是写前日志还是写后日志？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-6-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%87%E7%94%A8%E5%86%99%E5%90%8E%E6%97%A5%E5%BF%97%EF%BC%9F\"><span class=\"toc-text\">3.6.1 为什么采用写后日志？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-7-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0AOF%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">3.7 如何实现AOF的？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-8-%E4%B8%89%E7%A7%8D%E5%86%99%E5%9B%9E%E7%AD%96%E7%95%A5%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">3.8 三种写回策略的优缺点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-9-%E4%BB%80%E4%B9%88%E6%98%AFAOF%E9%87%8D%E5%86%99%EF%BC%9F\"><span class=\"toc-text\">3.9 什么是AOF重写？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-10-AOF%E9%87%8D%E5%86%99%E4%BC%9A%E9%98%BB%E5%A1%9E%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">3.10 AOF重写会阻塞吗？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-11-AOF%E6%97%A5%E5%BF%97%E4%BD%95%E6%97%B6%E4%BC%9A%E9%87%8D%E5%86%99%EF%BC%9F\"><span class=\"toc-text\">3.11 AOF日志何时会重写？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-12-AOF%E9%87%8D%E5%86%99%E6%97%A5%E5%BF%97%E6%97%B6%EF%BC%8C%E6%9C%89%E6%96%B0%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E5%92%8B%E6%95%B4%EF%BC%9F\"><span class=\"toc-text\">3.12 AOF重写日志时，有新数据写入咋整？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-13-%E4%B8%BB%E7%BA%BF%E7%A8%8Bfork%E5%87%BA%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%8D%E5%88%B6%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">3.13 主线程fork出子进程的是如何复制内存数据的？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-14-%E5%9C%A8%E9%87%8D%E5%86%99%E6%97%A5%E5%BF%97%E6%95%B4%E4%B8%AA%E8%BF%87%E7%A8%8B%E6%97%B6%EF%BC%8C%E4%B8%BB%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%E4%BC%9A%E8%A2%AB%E9%98%BB%E5%A1%9E%EF%BC%9F\"><span class=\"toc-text\">3.14 在重写日志整个过程时，主线程有哪些地方会被阻塞？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-15-%E4%B8%BA%E4%BB%80%E4%B9%88AOF%E9%87%8D%E5%86%99%E4%B8%8D%E5%A4%8D%E7%94%A8%E5%8E%9FAOF%E6%97%A5%E5%BF%97%EF%BC%9F\"><span class=\"toc-text\">3.15 为什么AOF重写不复用原AOF日志？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-16-Redis-%E8%BF%87%E6%9C%9F%E9%94%AE%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">3.16 Redis 过期键的删除策略有哪些?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-17-Redis-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">3.17 Redis 内存淘汰算法有哪些?</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-17-1-%E4%B8%8D%E6%B7%98%E6%B1%B0\"><span class=\"toc-text\">3.17.1 不淘汰</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-17-2-%E5%AF%B9%E8%AE%BE%E7%BD%AE%E4%BA%86%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%AD%E8%BF%9B%E8%A1%8C%E6%B7%98%E6%B1%B0\"><span class=\"toc-text\">3.17.2 对设置了过期时间的数据中进行淘汰</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-17-3-%E5%85%A8%E9%83%A8%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E6%B7%98%E6%B1%B0\"><span class=\"toc-text\">3.17.3 全部数据进行淘汰</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-18-Redis%E7%9A%84%E5%86%85%E5%AD%98%E7%94%A8%E5%AE%8C%E4%BA%86%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">3.18 Redis的内存用完了会发生什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-19-Redis%E5%A6%82%E4%BD%95%E5%81%9A%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%EF%BC%9F\"><span class=\"toc-text\">3.19 Redis如何做内存优化？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-20-Redis-key-%E7%9A%84%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E5%92%8C%E6%B0%B8%E4%B9%85%E6%9C%89%E6%95%88%E5%88%86%E5%88%AB%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE%EF%BC%9F\"><span class=\"toc-text\">3.20 Redis key 的过期时间和永久有效分别怎么设置？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-21-Redis-%E4%B8%AD%E7%9A%84%E7%AE%A1%E9%81%93%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F\"><span class=\"toc-text\">3.21 Redis 中的管道有什么用？</span></a></li></ol></li></ol>","author":{"name":"Fausto Wu","slug":"blog-author","avatar":"https://himg.bdimg.com/sys/portrait/item/pp.1.6326f07e.mlPaRS5MgyJSkED3WMXgqA?_t=1710767464259","link":"/","description":"编程优雅化。<br>Elegant programming.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"JavaSE面试问题总结——答案版","uid":"531f170567168922331d8060bfe590e6","slug":"JavaSE面试问题总结——答案版","date":"2024-03-19T08:08:30.000Z","updated":"2024-03-25T11:44:33.492Z","comments":true,"path":"api/articles/JavaSE面试问题总结——答案版.json","keywords":null,"cover":null,"text":"1. 面向对象1.1 什么是面向对象编程？面向对象编程是一种程序设计思想，通过将问题抽象成对象，通过对象之间的交互和数据封装来实现程序逻辑。 1.2 Java中...","permalink":"/post/JavaSE面试问题总结——答案版","photos":[],"count_time":{"symbolsCount":"32k","symbolsTime":"29 mins."},"categories":[],"tags":[{"name":"八股","slug":"八股","count":3,"path":"api/tags/八股.json"}],"author":{"name":"Fausto Wu","slug":"blog-author","avatar":"https://himg.bdimg.com/sys/portrait/item/pp.1.6326f07e.mlPaRS5MgyJSkED3WMXgqA?_t=1710767464259","link":"/","description":"编程优雅化。<br>Elegant programming.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}