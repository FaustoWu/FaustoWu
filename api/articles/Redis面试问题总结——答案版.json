{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Redis面试问题总结——答案版","date":"2024-03-18T12:41:18.824Z","updated":"2024-03-16T10:42:20.000Z","comments":true,"path":"api/articles/Redis面试问题总结——答案版.json","keywords":null,"cover":[],"content":"<h1 id=\"1-常规问题\"><a href=\"#1-常规问题\" class=\"headerlink\" title=\"1. 常规问题\"></a>1. 常规问题</h1><h2 id=\"1-1-什么是Redis，为什么用Redis？\"><a href=\"#1-1-什么是Redis，为什么用Redis？\" class=\"headerlink\" title=\"1.1 什么是Redis，为什么用Redis？\"></a>1.1 什么是Redis，为什么用Redis？</h2><p>Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。</p>\n<p>• 读写性能优异：Redis能读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s （测试条件见下一节）。</p>\n<p>• 数据类型丰富：Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</p>\n<p>• 原子性：Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</p>\n<p>• 丰富的特性：Redis支持 publish&#x2F;subscribe, 通知, key 过期等特性。</p>\n<p>• 持久化：Redis支持RDB, AOF等持久化方式</p>\n<p>• 发布订阅：Redis支持发布&#x2F;订阅模式</p>\n<p>• 分布式：Redis Cluster</p>\n<h2 id=\"1-2-为什么Redis-是单线程的以及为什么这么快？\"><a href=\"#1-2-为什么Redis-是单线程的以及为什么这么快？\" class=\"headerlink\" title=\"1.2. 为什么Redis 是单线程的以及为什么这么快？\"></a>1.2. 为什么Redis 是单线程的以及为什么这么快？</h2><p>• <strong>redis完全基于内存</strong>,绝大部分请求是纯粹的内存操作,非常快速.</p>\n<p>• <strong>数据结构简单</strong>,对数据操作也简单,redis中的数据结构是专门进行设计的</p>\n<p>• <strong>采用单线程模型</strong>, 避免了不必要的上下文切换和竞争条件, 也不存在多线程或者多线程切换而消耗CPU, 不用考虑各种锁的问题, 不存在加锁, 释放锁的操作, 没有因为可能出现死锁而导致性能消耗</p>\n<p>• <strong>使用了<u>多路IO复用模型</u></strong>,非阻塞IO</p>\n<p>• 使用底层模型不同,它们之间底层实现方式及与客户端之间的 通信的应用协议不一样,<strong><u>Redis直接构建了自己的VM机制</u></strong>,因为一般的系统调用系统函数的话,会浪费一定的时间去移动和请求</p>\n<h2 id=\"1-3-Redis-一般有哪些使用场景？\"><a href=\"#1-3-Redis-一般有哪些使用场景？\" class=\"headerlink\" title=\"1.3. Redis 一般有哪些使用场景？\"></a>1.3. Redis 一般有哪些使用场景？</h2><p>可以结合自己的项目讲讲，比如</p>\n<p>• <strong>热点数据的缓存</strong></p>\n<p>缓存是Redis最常见的应用场景，之所有这么使用，主要是因为Redis读写性能优异。而且逐渐有取代**<u>memcached</u>**，成为首选服务端缓存的组件。而且，Redis内部是支持事务的，在使用时候能有效保证数据的一致性。</p>\n<p>• <strong>限时业务的运用</strong></p>\n<p>redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。</p>\n<p>• <strong>计数器相关问题</strong></p>\n<p>redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。</p>\n<p>• <strong>分布式锁</strong></p>\n<p>这个主要利用redis的setnx命令进行，setnx：”set if not exists”就是如果不存在则成功设置缓存同时返回1，否则返回0 ，这个特性在俞你奔远方的后台中有所运用，因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先 通过setnx设置一个lock，如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。</p>\n<p>在分布式锁的场景中，主要用在比如秒杀系统等。</p>\n<h1 id=\"2-数据类型和数据结构\"><a href=\"#2-数据类型和数据结构\" class=\"headerlink\" title=\"2. 数据类型和数据结构\"></a>2. 数据类型和数据结构</h1><h2 id=\"2-1-Redis-有哪些数据类型？\"><a href=\"#2-1-Redis-有哪些数据类型？\" class=\"headerlink\" title=\"2.1 Redis 有哪些数据类型？\"></a>2.1 Redis 有哪些数据类型？</h2><p> 5种基础数据类型，分别是：String、List、Set、Zset、Hash。</p>\n<p>结构类型结构存储的值结构的读写能力<strong>String字符串</strong>可以是字符串、整数或浮点数对整个字符串或字符串的一部分进行操作；对整数或浮点数进行自增或自减操作；<strong>List列表一个链表</strong>，链表上的每个节点都包含一个字符串对链表的两端进行push和pop操作，读取单个或多个元素；根据值查找或删除元素；<strong>Set集合</strong>包含字符串的无序集合字符串的集合，包含基础的方法有看是否存在添加、获取、删除；还包含计算交集、并集、差集等；<strong>Hash散列</strong>包含键值对的无序散列表包含方法有添加、获取、删除单个元素Zset有序集合和散列一样，用于存储键值对字符串成员与浮点数分数之间的有序映射；元素的排列顺序由分数的大小决定；包含方法有添加、获取、删除单个元素以及根据分值范围或成员来获取元素</p>\n<p>• 三种特殊的数据类型 分别是 HyperLogLogs（基数统计）， Bitmaps (位图) 和 geospatial （地理位置) </p>\n<h2 id=\"2-2-谈谈Redis-的对象机制（redisObject-？\"><a href=\"#2-2-谈谈Redis-的对象机制（redisObject-？\" class=\"headerlink\" title=\"2.2 谈谈Redis 的对象机制（redisObject)？\"></a>2.2 谈谈Redis 的对象机制（redisObject)？</h2><p>比如说， 集合类型就可以由字典和整数集合两种不同的数据结构实现， 但是， 当用户执行 ZADD 命令时， 他&#x2F;她应该不必关心集合使用的是什么编码， 只要 Redis 能按照 ZADD 命令的指示， 将新元素添加到集合就可以了。</p>\n<p>这说明, 操作数据类型的命令除了要对键的类型进行检查之外, 还需要根据数据类型的不同编码进行多态处理.</p>\n<p>为了解决以上问题, Redis 构建了自己的类型系统, 这个系统的主要功能包括:</p>\n<p>• redisObject 对象.</p>\n<p>• 基于 redisObject 对象的类型检查.</p>\n<p>• 基于 redisObject 对象的显式多态函数.</p>\n<p>• 对 redisObject 进行分配、共享和销毁的机制. </p>\n<h2 id=\"2-3-Redis-数据类型有哪些底层数据结构？\"><a href=\"#2-3-Redis-数据类型有哪些底层数据结构？\" class=\"headerlink\" title=\"2.3 Redis 数据类型有哪些底层数据结构？\"></a>2.3 Redis 数据类型有哪些底层数据结构？</h2><p>• 简单动态字符串 - sds</p>\n<p>• 压缩列表 - ZipList</p>\n<p>• 快表 - QuickList</p>\n<p>• 字典&#x2F;哈希表 - Dict</p>\n<p>• 整数集 - IntSet</p>\n<p>• 跳表 - ZSkipList</p>\n<h2 id=\"2-4-为什么要设计sds？\"><a href=\"#2-4-为什么要设计sds？\" class=\"headerlink\" title=\"2.4 为什么要设计sds？\"></a>2.4 为什么要设计<u>sds</u>？</h2><p><u><em>定义：<a href=\"https://so.csdn.net/so/search?q=Redis&spm=1001.2101.3001.7020\">Redis</a>中的SDS（Simple Dynamic Strings）是一种用于表示字符串的内部数据结构。</em></u></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> len; <span class=\"comment\">/* 存储字符串的长度 */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> alloc; <span class=\"comment\">/* 已经分配的总长度 */</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">char</span> flags; <span class=\"comment\">/* 存的这个结构的类型,其中的最低3个bit用来表示header的类型,剩余5位未使用 */</span></span><br><span class=\"line\">    <span class=\"type\">char</span> buf[]; <span class=\"comment\">/* 一个c字符串,用来存储真实的字符串 */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>• 常数复杂度获取字符串长度</strong></p>\n<p>由于 len 属性的存在，我们获取 SDS 字符串的长度只需要读取 len 属性，时间复杂度为 O(1)。而对于 C 语言，获取字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。通过 strlen key 命令可以获取 key 的字符串长度。</p>\n<p><strong>• 杜绝缓冲区溢出</strong></p>\n<p>我们知道在 C 语言中使用 strcat 函数来进行两个字符串的拼接，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。而对于 SDS 数据类型，在进行字符修改的时候，会首先根据记录的 len 属性检查内存空间是否满足需求，如果不满足，会进行<u>相应的空间扩展</u>，然后在进行修改操作，所以不会出现缓冲区溢出。</p>\n<p><strong>• 减少修改字符串的内存重新分配次数</strong></p>\n<p>C语言由于不记录字符串的长度，所以如果要修改字符串，必须要重新分配内存（先释放再申请），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。</p>\n<p>而对于SDS，由于len属性和alloc属性的存在，对于修改字符串SDS实现了空间预分配和<u>惰性空间</u>释放两种策略：</p>\n<p><u><em>惰性空间，就像人具有懒惰性一样，空间的分配也可以具有懒惰性，简单说，如果Chunk在刚开始没有分配这么多空间，而是在需要的时候按需进行扩容，这种方法既节省了空间的浪费，也使得内部造成的碎片不会太多。</em></u></p>\n<ol>\n<li><p><strong>空间预分配</strong>：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。</p>\n</li>\n<li><p><strong>惰性空间释放</strong>：对字符串进行缩短操作时，程序不立即使用内存重新分配来回收缩短后多余的字节，而是使用 alloc 属性将这些字节的数量记录下来，等待后续使用。（当然SDS也提供了相应的API，当我们有需要时，也可以手动释放这些未使用的空间。）</p>\n</li>\n</ol>\n<p><strong>• 二进制安全</strong></p>\n<p>因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取；而所有 SDS 的API 都是以处理二进制的方式来处理 buf 里面的元素，并且 SDS 不是以空字符串来判断是否结束，而是以 len 属性表示的长度来判断字符串是否结束。</p>\n<p><strong>• 兼容部分 C 字符串函数</strong></p>\n<p>虽然 SDS 是二进制安全的，但是一样遵从每个字符串都是以空字符串结尾的惯例，这样可以重用 C 语言库&lt;string.h&gt; 中的一部分函数。 </p>\n<h2 id=\"2-5-Redis-一个字符串类型的值能存储最大容量是多少？\"><a href=\"#2-5-Redis-一个字符串类型的值能存储最大容量是多少？\" class=\"headerlink\" title=\"2.5 Redis 一个字符串类型的值能存储最大容量是多少？\"></a>2.5 Redis 一个字符串类型的值能存储最大容量是多少？</h2><p>512M</p>\n<h2 id=\"2-6-为什么会设计Stream？\"><a href=\"#2-6-为什么会设计Stream？\" class=\"headerlink\" title=\"2.6 为什么会设计Stream？\"></a>2.6 为什么会设计Stream？</h2><p>用过Redis做消息队列的都了解，基于Reids的消息队列实现有很多种，例如：</p>\n<p>• <u>PUB&#x2F;SUB，订阅&#x2F;发布模式</u></p>\n<p><u><em>Redis发布&#x2F;订阅（Pub&#x2F;Sub）是一种通信机制，将数据推到某个信息管道中，其他客户端可通过订阅这些管道来获取推送信息，以此用于消息的传输。由三部分组成：发布者（Publisher）、频道（Channel）、订阅者（Subscriber）。</em></u></p>\n<p>​\t但是发布订阅模式是无法持久化的，如果出现网络断开、Redis 宕机等，消息就会被丢弃；</p>\n<p>• 基于<u>List LPUSH+BRPOP</u> 或者 基于<u>Sorted-Set</u> 的实现</p>\n<ol>\n<li><em><u>使用LPUSH和BRPOP命令：LPUSH命令用于将一个或多个值插入到列表头部。BRPOP命令是RPOP的阻塞版本，它会移除并获得列表的最后一个元素，如果列表没有元素会阻塞列表直到等待时间超时或者收到一个元素。</u></em></li>\n<li><em><u>使用Sorted Set和BZPOPMAX命令：ZADD命令用于将一个或多个成员元素及其分数值加入到有序集当中。BZPOPMAX是ZPOPMAX的阻塞版本，它会移除并获取有序集合中分数最大的元素，如果有序集合为空，那么命令会阻塞，直到有元素添加到有序集合中或者指定的超时时间发生。</u></em></li>\n</ol>\n<p>​\t支持了持久化，但是不支持多播，分组消费等</p>\n<p><strong>消费组消费图</strong></p>\n<p><img src=\"https://i0.hdslb.com/bfs/article/1bff71f5a8a2c9e86eb419320b827273ee897840.png@1256w_!web-article-pic.avif\"></p>\n<h2 id=\"2-7-Redis-Stream用在什么样场景？\"><a href=\"#2-7-Redis-Stream用在什么样场景？\" class=\"headerlink\" title=\"2.7 Redis Stream用在什么样场景？\"></a>2.7 Redis Stream用在什么样场景？</h2><p>可用作时通信等，大数据分析，异地数据备份等</p>\n<p><img src=\"https://i0.hdslb.com/bfs/article/ae6f19f539c7100c0a1ffece3c1e2c101524e1ed.png@1256w_!web-article-pic.avif\"></p>\n<p>客户端可以平滑扩展，提高处理能力</p>\n<p><img src=\"https://i0.hdslb.com/bfs/article/860243cdc15bee3836fc054cf550842624e345f9.png@1256w_!web-article-pic.avif\"></p>\n<h2 id=\"2-8-Redis-Stream消息ID的设计是否考虑了时间回拨的问题？\"><a href=\"#2-8-Redis-Stream消息ID的设计是否考虑了时间回拨的问题？\" class=\"headerlink\" title=\"2.8 Redis Stream消息ID的设计是否考虑了时间回拨的问题？\"></a>2.8 Redis Stream消息ID的设计是否考虑了时间回拨的问题？</h2><p>XADD生成的1553439850328-0，就是Redis生成的消息ID，由两部分组成:时间戳-序号。时间戳是毫秒级单位，是生成消息的Redis服务器时间，它是个64位整型（int64）。序号是在这个毫秒时间点内的消息序号，它也是个64位整型。</p>\n<p>可以通过multi批处理，来验证序号的递增：</p>\n<p>由于一个redis命令的执行很快，所以可以看到在同一时间戳内，是通过序号递增来表示消息的。</p>\n<p>为了保证消息是有序的，因此Redis生成的ID是单调递增有序的。由于ID中包含时间戳部分，为了避免服务器时间错误而带来的问题（例如服务器时间延后了），Redis的每个Stream类型数据都维护一个latest_generated_id属性，用于记录最后一个消息的ID。若发现当前时间戳退后（小于latest_generated_id所记录的），则采用时间戳不变而序号递增的方案来作为新消息ID（这也是序号为什么使用int64的原因，保证有足够多的的序号），从而保证ID的单调递增性质。</p>\n<p>强烈建议使用Redis的方案生成消息ID，因为这种时间戳+序号的单调递增的ID方案，几乎可以满足你全部的需求。但同时，记住ID是支持自定义的，别忘了！ </p>\n","text":"1. 常规问题1.1 什么是Redis，为什么用Redis？Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列...","permalink":"/post/Redis面试问题总结——答案版","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E5%B8%B8%E8%A7%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">1. 常规问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E4%BB%80%E4%B9%88%E6%98%AFRedis%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8Redis%EF%BC%9F\"><span class=\"toc-text\">1.1 什么是Redis，为什么用Redis？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-%E4%B8%BA%E4%BB%80%E4%B9%88Redis-%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BB%A5%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB%EF%BC%9F\"><span class=\"toc-text\">1.2. 为什么Redis 是单线程的以及为什么这么快？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-Redis-%E4%B8%80%E8%88%AC%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F\"><span class=\"toc-text\">1.3. Redis 一般有哪些使用场景？</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">2. 数据类型和数据结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-Redis-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F\"><span class=\"toc-text\">2.1 Redis 有哪些数据类型？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E8%B0%88%E8%B0%88Redis-%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%88redisObject-%EF%BC%9F\"><span class=\"toc-text\">2.2 谈谈Redis 的对象机制（redisObject)？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-3-Redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F\"><span class=\"toc-text\">2.3 Redis 数据类型有哪些底层数据结构？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-4-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1sds%EF%BC%9F\"><span class=\"toc-text\">2.4 为什么要设计sds？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-5-Redis-%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E8%83%BD%E5%AD%98%E5%82%A8%E6%9C%80%E5%A4%A7%E5%AE%B9%E9%87%8F%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F\"><span class=\"toc-text\">2.5 Redis 一个字符串类型的值能存储最大容量是多少？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-6-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%AE%BE%E8%AE%A1Stream%EF%BC%9F\"><span class=\"toc-text\">2.6 为什么会设计Stream？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-7-Redis-Stream%E7%94%A8%E5%9C%A8%E4%BB%80%E4%B9%88%E6%A0%B7%E5%9C%BA%E6%99%AF%EF%BC%9F\"><span class=\"toc-text\">2.7 Redis Stream用在什么样场景？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-8-Redis-Stream%E6%B6%88%E6%81%AFID%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%98%AF%E5%90%A6%E8%80%83%E8%99%91%E4%BA%86%E6%97%B6%E9%97%B4%E5%9B%9E%E6%8B%A8%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F\"><span class=\"toc-text\">2.8 Redis Stream消息ID的设计是否考虑了时间回拨的问题？</span></a></li></ol></li></ol>","author":{"name":"Fausto Wu","slug":"blog-author","avatar":"/home/ftptest/img/myBlogLogo_min.jpg","link":"/","description":"A non famous and non professional technical blog.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"Hello World","uid":"b9663f58f18133b35bfe243f3e916a80","slug":"hello-world","date":"2024-03-18T06:22:09.342Z","updated":"2024-03-18T06:22:09.342Z","comments":true,"path":"api/articles/hello-world.json","keywords":null,"cover":null,"text":"Welcome to Hexo! This is your very first post. Check documentation for more info...","permalink":"/post/hello-world","photos":[],"count_time":{"symbolsCount":444,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Fausto Wu","slug":"blog-author","avatar":"/home/ftptest/img/myBlogLogo_min.jpg","link":"/","description":"A non famous and non professional technical blog.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}