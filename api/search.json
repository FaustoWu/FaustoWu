[{"id":"b101a1acd58b1556dc0f6a106802ccd2","title":"skyTakeOut项目技术要点","content":"1. niginx使用nginx的好处:\n提高访问速度\n进行负载均衡：把大量的请求按照我们指定的方式均衡党的分配给集群中的每台服务器\n保证后端服务安全\n\nnginx反向代理的配置方式123456789#nginx.confserver&#123;\tlisten 80;\tserver_name localhost;\t\tlocation/api/&#123;\t\tproxy_pass http://localhost:8080/admin/;#反向代理\t&#125;&#125;\n\nnginx负载均衡的配置方式12345678910111213#nginx.confupstream webservers&#123;    server 192.168.100.128:8080;    server 192.168.100.129:8080;&#125;server&#123;    listen 80;    server_name localhost;        location/api/&#123;        proxy_pass http://webservers/admin/;#负载均衡    &#125;&#125;\n\nnginx负载均衡策略1234567891011轮询：默认weight：依据权重ip_hash：依据ipleast_conn：依据最少链接url_hash：依据url分配fair：依据响应时间\n\n2. 密码加密使用MD5加密方式对明文密码加密（不可逆）\n12345//进行md5加密，然后进行比对password=DigestUtils.md5DisgestAsHex(password.getBytes());if(!password.equals(employee.getPassword()))&#123;    throw new PasswordErrorException(MessageConstant.PASSWORD_ERROR);&#125;\n\n3. YAPI接口管理平台4. Swagger——Knife4jKnife4j是Java MVC框架集成Swagger生成Api文档的增强解决方案。在线生成接口文档、在线测试接口。\n使用步骤\n导入Knife4j的maven坐标：\n\n123456//pom.xml&lt;dependency&gt;\t&lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;\t&lt;artifactId&gt;knifed-spring-boot-starter&lt;/artactId&gt;\t&lt;version&gt;3.0.2&lt;/version&gt;&lt;/dependency&gt;\n\n\n…\\config\\WebMvcConfiguration&#x2F; 配置类中加入knife4j相关配置：\n\n1234567891011121314151617@Beanpublic Docket docket()&#123;    Apilnfo apilnfo = new ApilnfoBuilder()        .title(&quot;苍穹外卖项自接口文档&quot;)        .version(&quot;2.0&quot;)        .description(&quot;苍穹外卖项目接口文档&quot;)        .build();    Docket docket = new Docket(DocumentationType.SWAGGER_2)        .apilnfo(apilnfo)        .select()        //指定生成接口需要扫描的包        .apis(RequestHandlerSelectors.basePackage(&quot;com.sky.controller&quot;))        .paths(PathSelectors.any())        .build();    return docket;&#125;\n\n\n…\\config\\WebMvcConfiguration&#x2F; 配置类中 设置静态资源映射，否则接口文档页面无法访问：\n\n1234567891011/** * 设置静态资源映射 * @param registry */protected void addResourceHandlers(ResourceHandlerRegistry registry)&#123;    log.info(&quot;开始设置静态资源映射...&quot;);    registry.addResourceHandler(&quot;/doc.html&quot;).addResourceLocations(&quot;classpath:/META-INFIresources&quot;);    registry.addResourceHandler(&quot;/webjars/&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/webjars&quot;);&#125;\n\n常用注解用于增加接口文档可读性\n1234567891011@Api(tag=&quot;员工相关接口&quot;)用在类上，例如Controller，表示对类的说明@ApiModel(description=&quot;员工登陆时传递的数据模型&quot;)用在类上，例如entity、DTO、vo@ApiModelProperty(&quot;用户名&quot;)用在属性上，描述属性信息@ApiOperation（value=&quot;员工登录&quot;）用在方法上，例如Controller的方法，说明方法的用途、作用\n\n5. 添加员工功能模块在控制类EmployeeController中\n12345678@PostMapping@ApiOperation(&quot;新增员工&quot;)public Result save(@RequestBody EmployeeDTO employeeDto)&#123;    Log.info(&quot;新增员工：&#123;&#125;&quot;,employeeDTO);    employeeService.save(employeeDTO);    \treturn Result.sucess();&#125;\n\n在service接口中声明方法，在lmpl中实现\n12345678910111213141516171819void save(EmployeeDTO employeeDTO)&#123;    //在持久层中要用实体，所以要把封装DTO转换为实体\tEmployee employee = new Employee();\tBeanUtils.copyPropertie(employeeDTO,employee);//属性名一致就可以使用对象属性拷贝    //设置账号状态    employee.setStatus(StatusConstant.ENABLE);    //设置密码,默认123456\temployee.setPassword(DisgestUtils.md5DigestAsHex(PasswordConstant.DEFAULT_PASSWORD.getBytes()));    //设置当前记录的创建时间和修改时间    employee.setCreateTime(LocalDateTime.now());    employee.updateCreateTime(LocalDateTime.now());        //TODO 后期需要修改为当前登录用户的ID    employee.setCreateUser(10L);    employee.updateCreateUser(10L);        employereeMapper.insert(employee);&#125;\n\n持久层EmployeeMapper中（要在配置文件中开启MyBatis的驼峰命名）\n12@Insert(&quot;insert into employee(...) values (#&#123;name&#125;,#&#123;username&#125;,...)&quot;)void insert(Employee employee);\n\n捕获sql中重复添加唯一属性字段的异常在GlobalExceptionHandler中\n1234567891011public Result excetionHandler(SQLIntegrityConstraintViolationException ex)&#123;\tString message = ex.getMessage();    if(message.contains(&quot;Duplicate entry&quot;))&#123;        String[] split = message.split(&quot; &quot;);        String username = split[2];        String msg = username + MessageConstant.ALREADY_EXISTS;        return Result.error(msg);    &#125;else&#123;        return Result.error(MessageConstant.UNKNOWN_ERROR);    &#125;&#125;\n\n解析JWT令牌存到ThreadLocal中JWT解析出员工ID后如何传递给Service的save方法？利用ThreadLocal存储空间。\nThreadLocal不是线程，是线程的局部变量，用于线程隔离，线程内才能读取。\n在context\\BaseContext中\n12345678910111213public static ThreadLocal&lt;long&gt; threadLocal = new ThreadLocal&lt;&gt;();public static void setCurrentId(Long id)&#123;\tthreadLocal.set(id);&#125;public static Long getCurrentId()&#123;\treturn threadLocal.get();&#125;public static void removeCurrentId()&#123;\tthreadLocal.remove();&#125;\n\n在拦截器JwtTokenAdminInterceptor中\n123456789101112131415161718//1.从请求头中获取令牌String token = request.getHeader(jwtProperies.getAdminTokenName());//2.校验令牌try&#123;    Log.info(&quot;jwt校验：&#123;&#125;&quot;,token);    Claims claims = JwtUtil.parseJWT(jwtProperties.getAdminSecretKey().token);    Long empId = long.valueOf(clains.get(JWTClaimsConstant.EMP_ID).toString());    Log.info(&quot;当前员工Id&quot;,empId);    BaseContext.setCurrentId(empId);    //3.通过放行    return ture&#125;catch&#123;    //4.不通过，响应401状态码    response.setStatus(401);    return false;&#125;\n\n在service中修改\n123//设置当前记录创建人和修改人ID    employee.setCreateUser(BaseContext.getCurrentId());    employee.updateCreateUser(BaseContext.getCurrentId());\n\n\n\n6. 分页查询功能实现在控制类EmployeeController中\n1234567@GetMapping(&quot;/page&quot;)@ApiOperation(&quot;员工分页查询&quot;)public Result&lt;PageResult&gt; page(EmployeePageQueryDTO employePageQueryDTO)&#123;    log.info(&quot;员工分页查询，参数为：&#123;&#125;&quot;,employePageQueryDTO)        PageResult pageResult = employeeService.pageQuery(employePageQueryDTO);\treturn Result.sucess(pageResult);&#125;\n\n在配置文件中导入pagehelper的maven坐标。\npagehelper底层是基于mybatis的拦截器实现的。\n在service中\n12345public PageResult pageQuery(EmployeePageQueryDTO employePageQueryDTO)&#123;    //select * from employee limit 0,10\tPageHelper.startPage(employePageQueryDTO.getPage(),employePageQueryDTO.getPageSize());    return null;&#125;\n\n\n","slug":"skyTakeOut项目技术要点","date":"2024-03-25T11:52:55.000Z","categories_index":"","tags_index":"项目","author_index":"Fausto Wu"},{"id":"e16c05f5e231a1a803fb1bd949e0f188","title":"企业生产SaaS项目技术实现细节","content":"一、关于数据源切换\n问：在项目中，如何实现企业数据源的动态切换？\n答：为了实现企业数据源的动态切换，我们采用了Hibernate与ThreadLocal的结合。Hibernate作为ORM框架，能够简化数据库操作。而ThreadLocal可以在每个线程中存储一个变量副本，这样每个请求都能拥有独立的数据源。当请求到来时，我们通过ThreadLocal获取当前请求对应的企业数据源，并设置到Hibernate的Session中，从而实现了数据源的动态切换。\n问：动态切换数据源的过程中，如何保证数据的安全性和准确性？\n答：在数据源切换的过程中，我们采取了多种措施来保证数据的安全性和准确性。首先，我们在切换数据源之前，会对数据源进行严格的验证，确保数据源的合法性和有效性。其次，我们在使用Hibernate时，会开启事务管理，确保每个操作都是原子性的，防止数据不一致的情况发生。此外，我们还对所有的数据访问操作进行了严格的权限控制，只有经过身份验证和授权的用户才能访问相应的数据。\n问：在实现数据源切换的过程中，有没有遇到什么技术难点？\n答：在实现数据源切换的过程中，我们确实遇到了一些技术难点。其中最主要的问题是如何保证线程安全和数据一致性。由于多个线程可能同时访问ThreadLocal中的数据源信息，我们需要确保每个线程都能获取到正确的数据源，并且不会受到其他线程的影响。为了解决这个问题，我们采用了线程局部变量的方式，确保每个线程都有自己独立的数据源信息。同时，我们还对数据库操作进行了事务管理，确保数据的一致性和完整性。\n问：Hibernate与MyBatis对比**\n1 相同点\nHibernate与MyBatis都可以是通过SessionFactoryBuider由XML配置文件生成SessionFactory，然后由SessionFactory 生成Session，最后由Session来开启执行事务和SQL语句。\n其中SessionFactoryBuider，SessionFactory，Session的生命周期都是差不多的。Hibernate和MyBatis都支持JDBC和JTA事务处理。\n2 不同点\n（1）hibernate是全自动，而mybatis是半自动\nhibernate完全可以通过对象关系模型实现对数据库的操作，拥有完整的JavaBean对象与数据库的映射结构来自动生成sql。而mybatis仅有基本的字段映射，对象数据以及对象实际关系仍然需要通过手写sql来实现和管理。\n（2）hibernate数据库移植性远大于mybatis\nhibernate通过它强大的映射结构和hql语言，大大降低了对象与数据库（Oracle、MySQL等）的耦合性，而mybatis由于需要手写sql，因此与数据库的耦合性直接取决于程序员写sql的方法，如果sql不具通用性而用了很多某数据库特性的sql语句的话，移植性也会随之降低很多，成本很高。\n（3）hibernate拥有完整的日志系统，mybatis则欠缺一些\nhibernate日志系统非常健全，涉及广泛，包括：sql记录、关系异常、优化警告、缓存提示、脏数据警告等；而mybatis则除了基本记录功能外，功能薄弱很多。\n（4）mybatis相比hibernate需要关心很多细节\nhibernate配置要比mybatis复杂的多，学习成本也比mybatis高。但也正因为mybatis使用简单，才导致它要比hibernate关心很多技术细节。mybatis由于不用考虑很多细节，开发模式上与传统jdbc区别很小，因此很容易上手并开发项目，但忽略细节会导致项目前期bug较多，因而开发出相对稳定的软件很慢，而开发出软件却很快。hibernate则正好与之相反。但是如果使用hibernate很熟练的话，实际上开发效率丝毫不差于甚至超越mybatis。\n（5）sql直接优化上，mybatis要比hibernate方便很多\n由于mybatis的sql都是写在xml里，因此优化sql比hibernate方便很多。而hibernate的sql很多都是自动生成的，无法直接维护sql；虽有hql，但功能还是不及sql强大，见到报表等变态需求时，hql也歇菜，也就是说hql是有局限的；hibernate虽然也支持原生sql，但开发模式上却与orm不同，需要转换思维，因此使用上不是非常方便。总之写sql的灵活度上hibernate不及mybatis。\n（6）缓存机制上，hibernate要比mybatis更好一些\nMyBatis的二级缓存配置都是在每个具体的表-对象映射中进行详细配置，这样针对不同的表可以自定义不同的缓存机制。并且Mybatis可以在命名空间中共享相同的缓存配置和实例，通过Cache-ref来实现。\n而Hibernate对查询对象有着良好的管理机制，用户无需关心SQL。所以在使用二级缓存时如果出现脏数据，系统会报出错误并提示。\n二、关于Spring的BeanPostProcessor扩展\n问：为什么选择实现Spring的BeanPostProcessor扩展接口？\n答：实现Spring的BeanPostProcessor扩展接口可以让我们在Spring容器创建Bean的过程中进行自定义的处理。通过这个接口，我们可以暴露一些不需要进行身份验证的接口，提高系统的便捷性和灵活性。同时，我们还可以对Bean进行一些初始化操作或者后置处理，满足特定的业务需求。\n问：在项目中，你是如何使用Spring的BeanPostProcessor扩展接口来暴露不需要验证的接口的？\n答：在项目中，我们有一些接口是不需要进行身份验证的，如健康检查接口、日志收集接口等。为了方便地暴露这些接口，我们使用了Spring的BeanPostProcessor扩展接口。通过实现该接口，我们可以在Spring容器初始化Bean的过程中，对这些Bean进行自定义处理。具体来说，我们创建了一个自定义的BeanPostProcessor类，在该类中重写了postProcessBeforeInitialization方法。在该方法中，我们检查Bean的注解或配置信息，判断该Bean是否需要暴露为不需要验证的接口。如果是，则将其添加到一个特定的集合中。然后，在请求处理阶段，我们根据请求的URL判断是否需要验证。如果不需要验证，则直接从该集合中获取对应的Bean进行处理。通过这种方式，我们可以灵活地暴露不需要验证的接口。\n问：使用BeanPostProcessor有哪些优势？\n答：使用BeanPostProcessor具有以下优势：\nl 灵活性：BeanPostProcessor允许我们在Spring容器初始化Bean的过程中进行自定义处理，可以灵活地修改或增强Bean的功能。\nl 解耦：通过BeanPostProcessor，我们可以将Bean的初始化逻辑与业务逻辑分离，降低代码的耦合度，提高代码的可维护性。\nl 扩展性：BeanPostProcessor是一个扩展点，我们可以根据需要实现自己的BeanPostProcessor来处理特定的业务逻辑，实现功能的扩展。\n问：在实现BeanPostProcessor时，你遇到了哪些挑战？又是如何解决的？\n答：在实现BeanPostProcessor时，我们主要面临的挑战是如何准确地识别并处理需要暴露的接口。为了解决这个问题，我们定义了一套接口标识规范，并在BeanPostProcessor中根据这些标识进行特殊处理。此外，我们还对Spring的Bean生命周期进行了深入的了解和研究，确保在正确的时机进行Bean的处理。\n三、关于双预防生成排查任务的定时任务\n问：在双预防生成排查任务的定时任务中，你是如何解决OOM问题的？\n答：在双预防生成排查任务的定时任务中，我们确实遇到了OOM（Out of Memory）问题。这主要是由于生成数据库连接的速度比回收数据库连接线程的速度快导致的。为了解决这个问题，我们采用了单例模式来管理数据库连接池。具体来说，我们创建了一个单例的数据库连接池管理器类，该类负责创建、管理和回收数据库连接。在生成排查任务时，我们从该管理器中获取数据库连接，使用完毕后立即归还给管理器。通过这种方式，我们可以确保数据库连接的合理使用和及时回收，避免了OOM问题的发生。\n问：除了使用单例模式外，还有哪些措施可以帮助解决OOM问题？\n答：除了使用单例模式外，我们还可以采取以下措施来解决OOM问题：\nl 优化数据库操作：减少不必要的数据库查询和更新操作，避免产生大量的数据库连接。\nl 合理配置JVM参数：根据项目的实际情况，合理配置JVM的堆内存大小、垃圾回收策略等参数，提高JVM的性能和稳定性。\nl 使用缓存：对于频繁访问且不经常变动的数据，可以使用缓存来存储，减少对数据库的访问压力。\nl 监控和预警：使用监控工具对系统的内存使用情况进行实时监控，并设置合理的预警阈值，及时发现并解决潜在的OOM问题。\n四、关于作业票业务中特殊字段的处理\n问：作业票业务中的九大作业票有哪些特殊字段？\n答：作业票业务中的九大作业票各自具有不同的特殊字段，这些字段通常与作业类型、作业环境、安全要求等相关。例如，某些作业票可能需要记录作业人员的资质信息、作业设备的状态信息、作业环境的安全条件等。这些特殊字段对于作业票的管理和审批至关重要。\n问：你是如何使用MySql8中的Json新特性来处理这些特殊字段的？\n答：为了灵活处理这些特殊字段，我们利用了MySql8中的Json数据类型及其相关的新特性。我们将这些特殊字段存储为Json格式的数据，利用MySql8提供的Json函数进行查询和修改操作。这样，我们可以根据业务需求动态地添加、修改或删除字段，而无需修改数据库表结构。同时，Json数据类型也提供了较好的扩展性和灵活性，能够适应未来可能的业务变化。\n 在 MySQL 8 中引入了许多新的 JSON 相关功能，传统的关系型数据库可以使用这些功能来处理 JSON 数据。以下是一些处理特殊字段的常见操作：\n\n查询 JSON 字段数据：可以使用 JSON_EXTRACT() 或 -&gt; 运算符来提取 JSON 字段中的数据。例如：\n1SELECT json_data-&gt;&#x27;$.key&#x27; FROM table_name;\n\n更新 JSON 字段数据：使用 JSON_SET() 函数来更新 JSON 字段中的数据。例如：\n1UPDATE table_name SET json_data = JSON_SET(json_data, &#x27;$.key&#x27;, &#x27;new_value&#x27;) WHERE condition;\n\n插入 JSON 数据：通过将 JSON 数据直接插入到 JSON 字段中来插入新数据。例如：\n1INSERT INTO table_name (json_data) VALUES (&#x27;&#123;&quot;key&quot;: &quot;value&quot;&#125;&#x27;);\n\n查询特定条件下的 JSON 数据：可以使用 JSON_CONTAINS() 函数来查询满足特定条件的 JSON 数据。例如：\n1SELECT * FROM table_name WHERE JSON_CONTAINS(json_data, &#x27;&#123;&quot;key&quot;: &quot;value&quot;&#125;&#x27;);\n\n操作 JSON 数组：使用 JSON_ARRAY() 和 JSON_OBJECT() 来处理 JSON 数组。例如：\n12SELECT JSON_ARRAY(&#x27;value1&#x27;, &#x27;value2&#x27;);SELECT JSON_OBJECT(&#x27;key1&#x27;, &#x27;value1&#x27;, &#x27;key2&#x27;, &#x27;value2&#x27;);\n\n删除 JSON 字段中的数据：你可以使用 JSON_REMOVE() 函数来删除 JSON 字段中的数据。以下是一些示例：\n1UPDATE table_name SET json_data = JSON_REMOVE(json_data, &#x27;$.key&#x27;) WHERE condition;\n\n上面的示例中，JSON_REMOVE() 函数通过指定路径来删除 JSON 字段中的数据。你可以根据你的需求来调整路径和条件。\n删除整个 JSON 字段：使用 UPDATE 语句来将 JSON 字段设置为 NULL，从而删除整个 JSON 字段的数据：\n1UPDATE table_name SET json_data = NULL WHERE condition;\n\n","slug":"企业生产SaaS项目技术实现细节","date":"2024-03-25T11:47:27.000Z","categories_index":"","tags_index":"面经","author_index":"Fausto Wu"},{"id":"531f170567168922331d8060bfe590e6","title":"JavaSE面试问题总结——答案版","content":"1. 面向对象1.1 什么是面向对象编程？面向对象编程是一种程序设计思想，通过将问题抽象成对象，通过对象之间的交互和数据封装来实现程序逻辑。\n1.2 Java中的类和对象有什么区别？类是描述对象的模板，对象是类的实例。类定义了对象的属性和行为，而对象则具体地拥有这些属性和行为。\n1.3 什么是封装？为什么要使用封装？封装是将数据和方法包装在类中，并限制对数据的直接访问。封装可以隐藏内部细节，提供对外部的安全接口，并实现代码的重用和维护。\n1.4 什么是继承？有什么作用？继承是指子类继承父类的属性和方法。继承可以实现代码的重用，提高代码的可维护性和可扩展性。\n1.5 Java是否支持多继承？Java不支持多继承，一个类只能继承一个父类。但是Java支持接口的多实现，实现了多继承的效果。\n1.6 什么是多态？如何实现多态？多态是同一类型的对象在不同情况下表现出不同的行为。多态可以通过继承和接口的方式实现。父 父 &#x3D; new 子\n1.7 什么是抽象类？有什么作用？抽象类是不能被实例化的，它只能被继承。抽象类可以包含抽象方法和具体方法的定义，用于作为其他类的父类。\n1.8 什么是接口？有什么作用？接口是一组抽象方法的集合。接口定义了对象应该具备的行为，类可以实现（implements）接口来达到多继承的效果。\n1.9 Java中的构造方法有什么作用？构造方法是用于在创建对象时初始化对象的状态。它的名称与类名相同，没有返回类型。\n1.10 什么是重载和重写？重载发生在同一个类中，方法名相同、参数列表、返回类型、权限修饰符可以不同。重写发生在子类中，方法名相、参数列表、返回类型都相同，权限修饰符要大于父类方法，声明异常范围要小于父类方法，但是final和private修饰的方法不可重写。\n1.11 什么是静态方法和静态变量？静态方法和静态变量属于类级别，而不是对象级别。它们可以在类被加载时直接调用，无需创建对象。\n1.12 Java中如何实现数据的隐藏和封装？Java中通过访问控制修饰符（private、protected、public）来限制对类的属性和方法的访问。\n1.13 什么是内部类？有什么作用？内部类是定义在其他类内部的类。它可以访问外部类的成员，并提供了更好的封装性和代码组织性。\n1.14 什么是匿名类？匿名类是没有名字的内部类，它通常用于直接创建对象并重写父类或接口的方法。\n1.15 什么是单继承和多实现？Java中一个类只能继承一个父类，这称为单继承；但是一个类可以实现多个接口，称为多实现。\n1.16 Java中如何防止继承？通过将类声明为final，可以防止其他类继承该类。\n1.17  什么是对象的浅拷贝和深拷贝？浅拷贝是指复制对象时，简单地复制对象的引用；深拷贝是指复制对象时，复制对象的所有引用和对象本身。\n1.18 什么是重写equals()和hashCode()方法的作用？重写equals()方法可以定制对象之间的相等比较逻辑；重写hashCode()方法可以保证对象在哈希表中的正确存储和查找。\n1.19 什么是枚举类？枚举类是一种特殊的类，它限制对象的个数，并提供了更好的类型安全和代码可读性。\n1.20 super关键字和this关键字有何区别？super关键字用于访问父类的成员（属性和方法），this关键字用于访问当前对象的成员。 \n1.21 接口和抽象类的区别？（1）抽象类可以有构造方法，而接口没有；\n（2）抽象类可以有抽象方法和具体方法，接口只能有抽象方法；\n（3）抽象类的成员4种权限修饰符都可以修饰，接口只能用private。\n2. 异常2.1 Java中的异常分为哪几类？各自的特点是什么？Java中的异常可以分为可查异常（Checked Exception）、运行时异常（Runtime Exception）和错误（Error）三类。可查异常需要在代码中显式捕获或声明抛出，运行时异常可以选择捕获或声明抛出，错误通常是指虚拟机相关的问题，无法恢复。\n2.2 Java中的异常处理机制是什么？Java的异常处理机制使用try-catch-finally语句块来处理异常。try块用于包裹可能抛出异常的代码，catch块用于捕获和处理异常，finally块用于定义无论是否异常都需要执行的代码。\n2.3 描述一下try-catch-finally语句块的执行流程。当try块中的代码出现异常时，会立即跳转到对应的catch块进行处理。如果发现catch块中可以处理该异常，会执行相应的代码，然后继续执行finally块中的代码；如果没有匹配的catch块，当前方法会立即结束，异常会被抛给上一级调用者或者由虚拟机处理。不论是否发生异常，finally块中的代码总会被执行。\n2.4 throw和throws关键字的作用是什么？throw关键字用于主动抛出一个异常对象，可以在任何地方使用。throws关键字用于在方法上声明可能抛出的异常类型，告诉调用者需要处理这些异常。\n2.5 RuntimeException和Checked Exception有什么区别？RuntimeException是运行时异常，程序员可以选择捕获或声明抛出，但不强制要求。Checked Exception是可查异常，需要在代码中显式捕获或声明抛出。区别在于编译器是否会强制检查异常的处理。\n2.6 什么是异常链？①捕获一个异常后抛出另一个异常，②并且希望把原始异常的信息保存下来，这被称为异常链。所有Throwable的子类在构造器中都可以接受一个cause（因由）对象作为参数。这个cause就用来表示原始异常，这样通过把原始异常传递给新的异常，使得即使在当前位置创建并抛出了新的异常，也能通过这个异常链追踪到异常最初发生的位置。\n1234567891011121314151617181920212223242526import java.sql.SQLException;import java.sql.SQLIntegrityConstraintViolationException;public class TestMain &#123;    public static void throwSQLIntegrityConstraintViolationException() throws SQLIntegrityConstraintViolationException &#123;        throw new SQLIntegrityConstraintViolationException(&quot;exception-SQLIntegrityConstraintViolationException&quot;);    &#125;    public static void throwRuntimeException() &#123;        try &#123;            throwSQLIntegrityConstraintViolationException();        &#125; catch (SQLException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    public static void main(String[] args) &#123;        try &#123;            throwRuntimeException();        &#125;        catch (Exception e) &#123;            System.out.println(e.getCause());        &#125;    &#125;&#125;\n\n\n\n2.7 什么时候应该使用finally块？finally块一般用于执行无论是否发生异常都需要执行的代码，例如释放资源、关闭连接等。在异常处理过程中，finally块中的代码总会被执行，保证资源的释放。\n2.8 什么是异常处理的最佳实践？异常处理的最佳实践包括尽早捕获异常、准确抛出异常、避免空的catch块、适当使用finally块、理解并合理使用异常类型等。\n2.9 Error和Exception有什么区别？Error是指虚拟机相关的问题或者系统级别的问题，一般由虚拟机处理。Exception是指程序运行时出现的异常，需要程序员处理。\n2.10 什么是断言（assertion）和断言异常？断言用于在程序中进行验证和调试，通常用于在开发过程中检查程序的正确性。断言异常是一种特殊的异常，如java.lang.AssertionError，用于表示断言失败。\n2.11 什么是异常处理的原则？异常处理的原则包括“捕获并处理异常”、“仅捕获那些你能处理的异常”、“尽量不要捕获太宽泛的异常类型”和“使用合适的日志记录异常”。\n2.12 描述一下finally块中的return语句会如何影响方法的返回值？如果在finally块中使用了return语句，会覆盖在try块中使用的return语句，即以finally块中的return值为准。\n2.13 什么是异常的传递？异常的传递是指当一个方法抛出异常时，该异常会沿着调用栈向上传递，直到被捕获或者到达程序的顶层。\n2.14 什么是异常的过滤？异常的过滤是指在catch块中通过条件判断来筛选和处理特定的异常情况。\n2.15 在catch块中如何处理多个异常？可以使用多个catch块来处理不同的异常类型，或者使用一个catch块来处理多个异常类型，使用多个“|”分隔异常类型。\n2.16 什么是堆栈轨迹（Stack Trace）？堆栈轨迹是指异常抛出时输出的一系列方法调用的信息，包括方法名、行号等，用于追踪异常发生的路径。\n2.17 如何自定义异常？可以通过继承Exception或者RuntimeException类来创建自定义异常类，并添加相应的构造方法和其他属性。\n2.18 说一下NullPointerException和ArrayIndexOutOfBoundsException异常。NullPointerException是指访问空对象的属性或方法时抛出的异常，ArrayIndexOutOfBoundsException是指访问数组越界时抛出的异常。\n2.19 如何处理异常时避免内存泄漏？可以在catch块中及时释放资源，尤其是对于输入输出流、数据库连接等需要手动关闭的资源。\n2.20 异常捕获处理与错误码处理方式有何不同？异常捕获处理是一种以异常对象的形式表示程序执行中遇到的异常情况的方式，而错误码处理则是根据不同的情况返回不同的预定的错误码。 错误码处理相对简单，适用于简单的异常情况；异常捕获处理具有更好的可读性和可维护性，适用于复杂的异常情况。\n3. 常用类3.1 String是可变对象还是不可变对象？String是不可变对象，一旦创建就无法修改其值。每次对String进行修改操作都会生成一个新的String对象。\n3.2 如何比较两个String的值是否相等？可以使用equals方法来比较两个String的值是否相等（被重写过，实际上是比较的是内存地址），例如：String s1 &#x3D; “Hello”; String s2 &#x3D; “Hello”; s1.equals(s2)。\n3.3 &#x3D;&#x3D;和equals的区别？&#x3D;&#x3D;比较基本类型，比较的是值，&#x3D;&#x3D;比较引用类型，比较的是内存地址。\nequlas是Object类的方法，本质上与&#x3D;&#x3D;一样，但是有些类重写了equals方法，比如String的equals被重写后，比较的是内存地址，另外重写了equlas后，也必须重写hashcode()方法。\n3.4 String类的常用方法有哪些？String类的常用方法包括length()，charAt()，concat()，substring()，indexOf()，equals()，compareTo()等。\n3.5 String和StringBuilder&#x2F;StringBuffer的区别是什么？String是不可变对象，每次修改都会生成一个新的String对象；StringBuilder&#x2F;StringBuffer是可变对象，可以直接修改其值。\n3.6 StringBuilder和StringBuffer有何区别？StringBuilder是非线程安全的，适用于单线程环境下；StringBuffer是线程安全的，适用于多线程环境下。\n3.7 如何将一个字符串转换为大写字母或小写字母？可以使用**toUpperCase()方法将字符串转换为大写字母，使用toLowerCase()**方法将字符串转换为小写字母。\n3.8 如何判断一个字符串是否以特定的前缀或后缀开头或结尾？可以使用**startsWith()判断字符串是否以特定的前缀开头，使用endsWith()**判断字符串是否以特定的后缀结尾。\n3.9 如何将字符串拆分成数组或将数组拼接成字符串？可以使用**split()方法将字符串拆分成数组，使用join()**方法将数组拼接成字符串。\n3.10 如何去除字符串中的空格或特定的字符？可以使用**trim()方法去除字符串中的前后空格，使用replace()**方法替换指定的字符。\n3.11 String常量池是什么？String常量池是一个特殊的内存区域，用于存储字符串常量，避免重复创建相同的字符串对象。\n3.12 如何比较两个String对象的引用是否相等？可以使用&#x3D;&#x3D;操作符来比较两个String对象的引用是否相等，例如：String s1 &#x3D; “Hello”; String s2 &#x3D; “Hello”; s1 &#x3D;&#x3D; s2。\n3.13 如何判断一个字符串是否包含另一个字符串？可以使用**contains()**方法来判断一个字符串是否包含另一个字符串，例如：String str &#x3D; “Hello World”; str.contains(“Hello”)。\n3.14 如何将基本类型转换为对应的字符串表示？可以使用valueOf()方法将基本类型转换为对应的字符串表示，例如：String num &#x3D; String.valueOf(10);\n3.15 如何将字符串转换为对应的基本类型？可以使用**parseXXX()**方法将字符串转换为对应的基本类型，例如：int num &#x3D; Integer.parseInt(“10”);\n3.16 如何反转一个字符串？可以使用**StringBuilder&#x2F;StringBuffer的reverse()**方法来反转一个字符串，例如：StringBuilder sb &#x3D; new StringBuilder(“Hello”); sb.reverse();\n3.17 String类中的+操作符和concat()方法有何区别？String类中的+操作符底层实际上使用了StringBuilder&#x2F;StringBuffer的append()方法来进行字符串拼接；而concat()方法直接将字符串拼接。\n3.18 如何截取字符串的子串？可以使用**substring()**方法来截取字符串的子串，指定起始下标和结束下标，例如：String str &#x3D; “Hello World”; str.substring(6, 11);\n3.19 如何将字符串转换为字符数组？可以使用**toCharArray()**方法将字符串转换为字符数组，例如：String str &#x3D; “Hello”; char[] charArray &#x3D; str.toCharArray();\n3.20 如何将字符数组转换为字符串？可以使用String的构造方法或valueOf()方法将字符数组转换为字符串，例如：char[] charArray &#x3D; {‘H’, ‘e’, ‘l’, ‘l’, ‘o’}; String str &#x3D; new String(charArray);\n3.21 String对象的内存分配是放在栈上还是堆上？String对象的引用放在栈上，而String对象本身存储在堆上。\n3.22 如何将一个字符串转换为整数类型（int）？可以使用**Integer.parseInt()**方法将字符串转换为整数类型，例如：String str &#x3D; “123”; int num &#x3D; Integer.parseInt(str);\n3.23 如何将一个整数类型（int）转换为字符串？可以使用String.valueOf()方法或者将整数类型与空字符串相加（+” “）来将整数类型转换为字符串，例如：int num &#x3D; 123; String str &#x3D; String.valueOf(num); 或者 String str &#x3D; num + “”;\n3.24 如何判断一个字符串是否为空或者只包含空格？可以使用**isEmpty()方法或者trim()**方法（若含有空格）来判断一个字符串是否为空，例如：String str &#x3D; “”; boolean isEmpty &#x3D; str.isEmpty(); 或者 String str &#x3D; “ “; boolean isBlank &#x3D; str.trim().isEmpty();\n3.25 如何将一个字符串中的字符按照指定的分隔符拆分成数组？可以使用split()方法来将一个字符串按照指定的分隔符拆分成数组，例如：String str &#x3D; “Hello,World”; String[] arr &#x3D; str.split(“,”);\n3.26 如何将字符串中的字符全部替换为指定字符？可以使用replace()方法来将字符串中的字符全部替换为指定字符，例如：String str &#x3D; “Hello World”; String newStr &#x3D; str.replace(‘o’, ‘*’); \n3.27 如何将指定的字符插入到字符串指定的位置？可以使用substring()方法和concat()方法来将指定的字符插入到字符串指定的位置，例如：String str &#x3D; “Hello”; String newStr &#x3D; str.substring(0, 2).concat(“XX”).concat(str.substring(2));\n3.28 如何将字符串转换为大写或小写，并忽略字符串中的特殊字符？可以使用**toLowerCase()方法或toUpperCase()方法将字符串转换为大写或小写，并使用replaceAll()**方法去除特殊字符，例如：String str &#x3D; “Hello,@World!”; String lowerCase &#x3D; str.replaceAll(“[ ^a-zA-Z0-9 ]”, “”).toLowerCase();\n3.29 如何获取字符串中指定字符的索引位置？可以使用indexOf()方法或lastIndexOf()方法来获取字符串中指定字符的索引位置，例如：String str &#x3D; “Hello”; int index &#x3D; str.indexOf(‘o’);\n3.30 如何将多个字符串拼接成一个字符串？可以使**用StringBuilder&#x2F;StringBuffer的append()**方法进行字符串拼接，例如：StringBuilder sb &#x3D; new StringBuilder(); sb.append(“Hello”).append(“World”);\n3.31 如何判断两个字符串是否相等，忽略大小写？可以使用**equalsIgnoreCase()**方法来判断两个字符串是否相等，忽略大小写，例如：String str1 &#x3D; “Hello”; String str2 &#x3D; “hello”; boolean isEqual &#x3D; str1.equalsIgnoreCase(str2);\n3.32 Java中的八种基本类型与其对应的包装类分别是什么？八种基本类型及对应的包装类如下：boolean - Boolean、byte - Byte、char - Character、short - Short、int - Integer、long - Long、float - Float、double - Double。\n3.33 如何将基本类型转换为对应的包装类？可以使用包装类的构造方法或者**valueOf()**方法将基本类型转换为对应的包装类，例如：int num &#x3D; 10; Integer obj &#x3D; new Integer(num); 或者 Integer obj &#x3D; Integer.valueOf(num);\n3.34 如何将包装类转换为对应的基本类型？可以使用**包装类的xxxValue()**方法将包装类转换为对应的基本类型，例如：Integer obj &#x3D; new Integer(10); int num &#x3D; obj.intValue();\n3.35 如何将字符串转换为对应的包装类？可以使用**包装类的valueOf()**方法将字符串转换为对应的包装类，例如：String str &#x3D; “10”; Integer obj &#x3D; Integer.valueOf(str);\n3.36 如何将包装类转换为对应的字符串？可以使用**包装类的toString()**方法将包装类转换为对应的字符串，例如：Integer obj &#x3D; new Integer(10); String str &#x3D; obj.toString();\n3.37 如何比较两个包装类的值是否相等？可以使用equals()方法或**&#x3D;&#x3D;**操作符来比较两个包装类的值是否相等，例如：Integer obj1 &#x3D; new Integer(10); Integer obj2 &#x3D; new Integer(10); boolean isEqual &#x3D; obj1.equals(obj2) 或者 obj1 &#x3D;&#x3D; obj2;\n3.38 自动拆箱和自动装箱是什么意思？自动拆箱是指将包装类的对象自动转换为基本类型的过程，例如：Integer obj &#x3D; new Integer(10); int num &#x3D; obj; 自动装箱是指将基本类型自动转换为包装类的对象，例如：int num &#x3D; 10; Integer obj &#x3D; num;\n3.39 包装类和基本类型存储在内存中的位置有什么区别？基本类型的变量存储在栈内存中，而包装类对象存储在堆内存中。\n3.40 包装类的缓存是什么意思？在范围较小的数值范围中，Java的包装类会使用缓存来提高性能，例如Integer类会缓存-128至127之间的整数对象。\n3.41 在使用包装类时如何避免空指针异常？可以使用**包装类的valueOf()**方法，该方法如果传入的字符串为null，则会返回null值。例如：String str &#x3D; null; Integer obj &#x3D; Integer.valueOf(str);\n3.42 String赋值给包装类对象时会发生什么？当将一个String类型的值赋给包装类对象时，会自动调用包装类的valueOf()方法将字符串转换为包装类对象。\n3.43 包装类有哪些方法可以将字符串转换为对应的基本类型？包装类提供了许多方法将字符串转换为对应的基本类型，例如：Boolean类的parseBoolean()、Byte类的parseByte()、Integer类的parseInt()等。\n3.44 包装类的valueOf()方法和xxxValue()方法有什么区别？valueOf()方法将基本类型或字符串转换为包装类对象，xxxValue()方法将包装类对象转换为对应的基本类型。\n3.45 包装类对象如何比较大小？可以使用**包装类的compareTo()**方法来比较大小，或者将包装类对象转换为基本类型后再进行比较。\n3.46 为什么会出现基本类型和包装类之间的装箱和拆箱？基本类型和包装类之间的装箱和拆箱是为了在需要使用对象而只有基本类型的地方提供方便，同时也是为了实现一些储存和操作的需求。\n3.47 如何判断一个变量的类型是否是包装类？可以使用instanceof关键字来判断一个变量的类型是否是包装类，例如：if (obj instanceof Integer) { &#x2F;&#x2F; do something }\n3.48 包装类的作用是什么？包装类的主要作用是将基本类型转换为对象，以便于在需要使用对象的场景中进行操作，同时也提供了一些常用的方法和功能。\n3.49 在什么情况下会自动拆箱和自动装箱？自动拆箱和自动装箱在需要使用基本类型的地方进行拆箱操作，或者在需要使用对象的地方进行装箱操作。\n3.50 包装类和基本类型之间的转换会有什么影响？包装类和基本类型之间的转换会涉及到性能和内存消耗方面的影响，其中自动装箱和自动拆箱会带来一定的性能开销。 \n3.51 Java中处理日期和时间的类有哪些？Java中处理日期和时间的类主要有java.util.Date、java.util.Calendar、java.time.LocalDate、java.time.LocalDateTime等。\n3.52 如何获取当前的日期和时间？可以使用java.util.Date类的无参构造方法得到当前的日期和时间，或者使用**java.time.LocalDateTime的now()**方法。\n3.53 如何格式化日期和时间？可以使用java.text.SimpleDateFormat类来格式化日期和时间，通过指定格式的字符串将日期和时间转换为指定格式。\n3.54 如何在Java中表示一个特定的日期？可以使用java.util.Calendar类或java.time.LocalDate类来表示一个特定的日期。\n3.55 如何计算两个日期之间的天数差距？可以使用java.util.Calendar类或java.time.LocalDate类的方法来计算两个日期之间的天数差距，然后进行相减运算。\n3.56 如何将日期转换为字符串？可以使用java.util.Date类的toString()方法将日期对象转换为字符串，或者使用java.text.SimpleDateFormat类进行自定义格式的转换。\n3.57 如何将字符串转换为日期？可以使用java.text.SimpleDateFormat类的**parse()**方法将字符串转换为日期对象，需要指定匹配的日期格式。\n3.58 如何在Java中进行日期的加减操作？可以使用java.util.Calendar类或java.time.LocalDateTime类的**add()**方法进行日期的加减操作。\n3.59 Java中日期和时间的处理在多线程环境下是否安全？java.util.Date类和java.util.Calendar类在多线程环境下是不安全的，可以使用java.time包中的类来实现线程安全的日期和时间处理。\n3.60 Java中如何比较两个日期是否相等？可以使用java.util.Date类的equals()方法或者java.time.LocalDate类的isEqual()方法来判断两个日期是否相等。\n3.61 Java中如何获取某个日期的年、月、日、星期等具体信息？可以使用java.util.Calendar类或java.time.LocalDate类的**get()**方法来获取某个日期的年、月、日、星期、一年中的第几天等具体信息。\n3.62 Java中如何获取某个日期的下一天或上一天？可以使用java.util.Calendar类或java.time.LocalDate类的**add()**方法来进行日期的加减操作，从而得到下一天或上一天的日期。\n3.63 Java中如何判断某个日期是在另一个日期之前还是之后？可以使用java.util.Date类的**before()和after()**方法，或者使用java.time.LocalDate类的isBefore()和isAfter()方法来判断日期的先后关系。\n3.64 Java中如何将日期设置为零点或午夜？可以使用java.util.Calendar类或java.time.LocalDateTime类的**set()**方法来将日期设置为零点或午夜。\n3.65 Java中的String、StringBuffer和StringBuilder有什么区别？String是不可变类，每次对String的操作都会创建新的String对象，StringBuffer和StringBuilder是可变类，可以在原始字符串上进行修改。\n3.66 String、StringBuffer和StringBuilder之间的性能差异是什么？由于String是不可变的，每次对String进行操作时都会创建新的String对象，因此在频繁进行字符串操作时，使用StringBuffer和StringBuilder性能更好。 \n3.67 StringBuffer和StringBuilder之间的区别是什么？StringBuffer是线程安全的，适用于多线程环境，而StringBuilder是非线程安全的，适用于单线程环境。\n3.68 如何将String类型的字符串转换为StringBuffer或StringBuilder类型？可以使用StringBuffer或StringBuilder的构造方法将String类型的字符串转换为StringBuffer或StringBuilder类型，例如：StringBuffer sb &#x3D; new StringBuffer(“Hello”); 或者 StringBuilder sb &#x3D; new StringBuilder(“Hello”);\n3.69 如何在Java中连接多个字符串？可以使用”+“运算符进行字符串的连接，也可以使用**StringBuffer或StringBuilder的append()**方法进行字符串的连接。\n3.70 为什么String对象是不可变的？String对象是不可变的，主要是为了提高字符串的安全性和线程安全性。\n3.71 StringBuffer和StringBuilder的常用方法有哪些？StringBuffer和StringBuilder具有相似的方法，包括append()、insert()、delete()、replace()、reverse()等方法。\n3.72 何时应该使用StringBuffer，何时应该使用StringBuilder？应该在多线程环境下使用StringBuffer，因为它是线程安全的；在单线程环境下使用StringBuilder，因为它的性能更好。\n3.73 如何定义一个枚举类？可以使用enum关键字定义一个枚举类。\n3.74 枚举类的常量有什么特点？枚举类的常量是唯一的、有限的且已命名的，不能再次赋值。\n3.75 枚举类的常量可以有自己的属性和方法吗？是的，枚举类的常量可以有自己的属性和方法。\n3.76 如何访问枚举类中的常量？可以使用枚举类名和常量名来访问枚举类中的常量。\n3.77 枚举类可以实现接口吗？是的，枚举类可以实现一个或多个接口。\n3.78 如何遍历枚举类中的常量？可以使用枚举类的**values()**方法获取枚举类的所有常量，并进行遍历。\n3.79 如何通过字符串获取枚举类中的常量？可以使用枚举类的valueOf()方法，传入常量的字符串名称来获取对应的常量。\n3.80 枚举类与普通类的区别是什么？枚举类可以确保常量的唯一性且类型安全，可以直接比较和使用，而普通类则需要通过对象来比较和使用。\n3.81 枚举类在实际开发中的应用场景有哪些？枚举类在实际开发中常用于定义一组相关常量、状态机、单例模式等场景。\n3.82 如何比较两个枚举常量的顺序？可以使用枚举常量的**compareTo()**方法来比较两个枚举常量的顺序。\n3.83 枚举类的构造方法可以是私有的吗？是的，枚举类的构造方法可以是私有的。\n3.84 枚举类如何定义自己的方法？可以在枚举类中定义自己的方法，常量可以调用这些方法进行特定的操作。\n3.85 枚举类可以继承其他类吗？Java中的枚举类默认继承自java.lang.Enum类，不支持继承其他类。\n3.86 如何在枚举类中添加更多的属性？可以在枚举类中添加成员变量，并在构造方法中为其赋值，每个常量都会具有相应的属性。\n3.87 枚举类的构造方法在何时被调用？每个枚举常量的构造方法在枚举类加载时被调用。\n3.88 枚举类可以作为方法的参数和返回值吗？是的，枚举类可以作为方法的参数和返回值。\n3.89 如何扩展枚举类的功能？可以使用抽象方法，在枚举类的每个常量中实现该抽象方法，以便为每个常量定制不同的行为。\n123456789101112131415161718enum Color&#123;    RED&#123;        public String getColor()&#123;//枚举对象实现抽象方法            return &quot;红色&quot;;        &#125;    &#125;,    GREEN&#123;        public String getColor()&#123;//枚举对象实现抽象方法            return &quot;绿色&quot;;        &#125;    &#125;,    BLUE&#123;        public String getColor()&#123;//枚举对象实现抽象方法            return &quot;蓝色&quot;;        &#125;    &#125;;    public abstract String getColor();//定义抽象方法&#125;\n\n3.90 枚举类可以实现单例模式吗？是的，枚举类天然的单例模式可以保证线程安全和实例唯一性。  \n4. 多线程4.1 进程和线程的区别？进程：系统运行的基本单位，包含多个线程\n线程：独立运行的最小单位，是进程的实体，多个线程共享同一进程内的系统资源\n4.2 Java中创建线程的方式有哪些？创建线程的方式有继承Thread类、实现Runnable接口、实现Callable接口并通过Executor框架进行调度等方式。\n4.3 创建线程的方式中，哪种更常用？为什么？更常用的方式是实现Runnable接口，因为Java不支持多重继承，通过实现Runnable接口可以更好地组织和管理线程。\n4.4 如何启动一个线程？启动一个线程可以调用线程对象的**start()**方法。\n4.5 run()方法和start()方法有什么区别？run()方法是线程的执行方法，通过调用start()方法来启动线程，会自动调用run()方法。\n4.6 线程的生命周期有哪些状态？线程的状态包括新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）、等待（Waiting）、超时等待（Timed Waiting）、终止（Terminated）。线程状态流转可以是新建-&gt;就绪-&gt;运行-&gt;阻塞-&gt;就绪-&gt;运行-&gt;终止。\n4.7 怎样停止一个正在运行的线程？通常使用标志位的方式停止一个线程，通过修改标志位来控制线程的执行。\n4.8 什么是线程安全？如何保证线程安全？线程安全是指多个线程访问共享数据时，不会出现数据不一致或数据冲突的情况。可以使用synchronized关键字或Lock接口来保证线程安全。\n4.9 什么是线程间通信？如何实现线程间通信？线程间通信是指多个线程之间通过发送和接收消息来进行协作。可以使用wait()、notify()和notifyAll()方法实现线程间通信。\n4.10 什么是线程死锁？如何避免线程死锁？线程死锁是指多个线程相互等待对方释放资源而无法继续执行的情况。可以避免线程死锁的方法包括避免循环等待、按照相同的顺序获取资源等。\n4.11 什么是线程优先级？如何设置线程优先级？线程优先级是操作系统对线程调度的参考值，可以使用setPriority()方法设置线程的优先级。\n4.12 什么是守护线程？守护线程是一种特殊的线程，它的作用是为其他线程提供便利的服务，当所有非守护线程结束时，守护线程会自动被销毁。\n4.13 什么是线程的上下文切换？在什么情况下会发生线程的上下文切换？线程的上下文切换是指CPU从一个线程切换到另一个线程执行的过程。线程的上下文切换会在多核CPU中或出现线程阻塞和线程优先级变化时发生。\n4.14 什么是线程池？为什么要使用线程池？线程池是一种管理和复用线程的机制，可以避免重复创建和销毁线程，提高资源利用率和系统性能。\n4.15 Java中如何使用线程池？可以通过ThreadPoolExecutor类或Executors工具类来创建线程池。\n4.16 线程池有哪些常用的创建方式？常用的创建线程池的方式有n**ewFixedThreadPool()、newCachedThreadPool()、newSingleThreadExecutor()**等。\n4.17 线程池的核心线程数和最大线程数有什么区别？核心线程数是线程池最少保留的线程数，最大线程数是线程池所能容纳的最大线程数。\n4.18 线程池七大参数？\n核心线程数：线程池中的基本线程数量\n\n最大线程数：当阻塞队列满了之后，逐一启动\n\n最大线程的存活时间：当阻塞队列的任务执行完后，最大线长的回收时间\n\n最大线程的存活时间单位\n\n阻塞队列：当核心线程满后，后面来的任务都进入阻塞队列\n\n线程工厂：用于生产线程\n\n任务拒绝策略：任务队列已满并且线程数达到最大线程数后，拒绝任务，有四种策略（1）抛异常（2）丢弃任务不抛异常（3）打回任务（4）尝试与最老的线程竞争\n\n\n4.19 什么是线程局部变量？线程局部变量是每个线程独立拥有的变量，每个线程都可以对其进行读写操作。\n4.20 什么是ThreadLocal类？如何在多线程中使用ThreadLocal？ThreadLocal原理？ThreadLocal类是Java中用于存储线程局部变量的类，每个线程都有一个与之关联的ThreadLocal对象，通过ThreadLocal的get()和set()方法可以在多线程中访问和修改线程局部变量。\n原理是为每个线程创建变量副本，不同线程之间不可见，保证线程安全。每个线程内部都维护了一个Map，key为threadLocal实例，value为要保存的副本。\n但是使用ThreadLocal会存在内存泄露问题，因为key为弱引用，而value为强引用，每次gc时key都会回收，而value不会被回收。所以为了解决内存泄漏问题，可以在每次使用完后删除value或者使用static修饰ThreadLocal，可以随时获取value\n4.21 Java中有几种锁的类型？请列举并简要解释。Java中有两种锁的类型，分别为对象锁（也称为内部锁或监视器锁）和类锁（也称为静态锁）。对象锁是在对象上的锁，使只有一个线程可以访问对象的同步代码块。类锁是在类上的锁，使只有一个线程可以访问类的同步代码块。\n4.22 synchronized关键字和Lock接口之间有什么区别？\nsynchronized是关键字，lock是一个类\n\nsynchronized在发生异常时会自动释放锁，lock需要手动释放锁\n\nsynchronized是可重入锁、非公平锁、不可中断锁，lock是可重入锁，可中断锁，可以是公平锁\n\n\n4.23 volatile关键字作用？单例模式双重校验锁变量为什么使用 volatile 修饰？volatile和synchronized的区别？用处：\nvolatile保证变量的可见性和有序性，不保证原子性。volatile关键字用于保证被修饰的变量在多线程环境下的可见性和禁止指令重排序。使用了 volatile 修饰变量后，在变量修改后会立即同步到主存中，每次用这个变量前会从主存刷新。它是一种轻量级的同步机制，适用于变量的读多写少的场景。\n单例模式双重校验锁变量为什么使用 volatile 修饰？ \n禁止 JVM 指令重排序，new Object()分为三个步骤：申请内存空间，将内存空间引用赋值给变量，变量初始化。如果不禁止重排序，有可能得到一个未经初始化的变量。\n区别：\n\nvolatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。\nvolatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的\nvolatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性\nvolatile不会造成线程 的阻塞；synchronized可能会造成线程的阻塞。\nvolatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化\n\n4.24 Java中的线程调度算法是什么？如何改变线程的调度优先级？Java中的线程调度算法是抢占式调度算法（preemptive scheduling），通过线程的优先级来决定下一个应该执行的线程。可以使用setPriority()方法来改变线程的调度优先级。\n4.25 什么是线程安全的集合？Java中有哪些线程安全的集合类？线程安全的集合是在多线程环境下可以安全使用的集合。Java中有诸如Vector、Hashtable、ConcurrentHashMap、CopyOnWriteArrayList和ConcurrentLinkedQueue等线程安全的集合类。\n4.26 什么是线程的上下文ClassLoader？它有什么作用？线程的上下文ClassLoader是线程的一个属性，用于寻找和加载类文件。ClassLoader可以指定线程在运行时加载类所使用的类加载器。\n4.27 什么是线程的上下文切换开销？如何减少上下文切换开销？线程的上下文切换开销是指在同一CPU内核上切换线程所耗费的时间和资源。可以通过减少线程的数量、避免线程的频繁切换和优化线程的调度来减少上下文切换开销。\n4.28 什么是线程的运行状态不安全问题（Race Condition）？如何避免？线程的运行状态不安全问题是由于多个线程同时访问和修改共享数据而导致的不确定性问题。可以使用同步机制（如锁）或使用线程安全的数据结构来避免运行状态不安全问题。\n4.29 什么是线程的休眠和阻塞？线程的休眠是指让线程暂停一段时间执行，可以使用Thread.sleep()来实现。线程的阻塞是指暂停线程的执行，直到某个条件满足，可以使用Object类的wait()方法来实现。\n4.30 什么是线程的调度策略？Java中的线程调度策略是什么？线程的调度策略是指操作系统或虚拟机如何决定在何时执行哪个线程。Java中的线程调度策略是由操作系统控制，通常基于线程的优先级和调度算法来决定。\n4.31 什么是线程锁？线程锁是一种同步机制，用于保护共享资源在多线程环境下的安全访问。\n4.32 Java中有哪些线程锁机制？Java中有两种线程锁机制，分别为synchronized关键字和Lock接口。\n4.33 synchronized关键字的作用是什么？synchronized关键字用于实现线程的互斥访问，确保同一时刻只有一个线程可以访问被synchronized关键字保护的代码块。\n4.34 synchronized关键字有哪些使用方式？synchronized关键字可以修饰实例方法、静态方法和代码块。\n4.35 什么是悲观锁和乐观锁？悲观锁是指假设会发生并发冲突，每次访问共享资源都会加锁。乐观锁是指假设不会发生并发冲突，只有在更新时才检查是否有冲突。\n4.36 什么是可重入锁（Reentrant Lock）？可重入锁是指同一个线程可以多次获得同一个锁，用于解决线程在递归调用等情况下对资源的重复加锁问题。\n4.37 什么是读写锁（ReadWriteLock）？读写锁是一种特殊的锁机制，允许多个线程同时读取共享资源，但在写操作时只允许一个线程访问。\n4.38 什么是公平锁和非公平锁？公平锁是指线程按照请求的顺序获得锁，非公平锁是指线程在请求时不考虑顺序，有机会直接获得锁。\n4.39 死锁的必要条件？如何避免死锁？互斥条件：同一资源同时只能由一个线程读取\n不可抢占条件：不能强行剥夺线程占有的资源\n请求和保持条件：请求其他资源的同时对自己手中的资源保持不放\n循环等待条件：在相互等待资源的过程中，形成一个闭环\n想要预防死锁，只需要破坏其中一个条件即可，银行家算法可以预防死锁，包括避免循环等待、按照相同的顺序获取锁、设置超时时间等。\n4.40 什么是线程的通信？线程的通信是指多个线程之间通过共享变量进行交互和传递信息的过程。\n4.41 Java中如何进行线程的通信？Java中可以使用Object类的wait()、notify()和notifyAll()方法进行线程的通信。\n4.42 wait()和sleep()方法有什么区别？\nwait()是Object的方法，sleep()是Thread类的方法\n\nwait()会释放锁，sleep()不会释放锁\n\nwait()要在同步方法或者同步代码块中执行，sleep()没有限制\n\nwait()要调用notify()或notifyall()唤醒,sleep()自动唤醒\n\n\n4.43 为什么wait()、notify()和notifyAll()方法必须在synchronized块内调用？wait()、notify()和notifyAll()方法必须在synchronized块内调用，因为它们依赖于对象的监视器锁。\n4.44 wait()方法和notify()方法的调用顺序有要求吗？是的，wait()方法应该在notify()方法之前被调用。\n4.45 为什么调用notify()方法后，不会立即释放锁？调用notify()方法后，线程只是通知其他线程可以竞争锁，但不会立即释放锁。\n4.46 notify()方法会通知哪个线程？notify()方法会随机通知等待该对象锁的一个线程。\n4.47 notifyAll()方法会通知哪些线程？notifyAll()方法会通知等待该对象锁的所有线程，让它们重新竞争锁。\n4.48 为什么在调用wait()方法时，需要使用while循环来测试条件？在多线程环境下，wait()方法被唤醒后，线程仍需再次检查等待条件是否满足，以防止虚假唤醒。\n4.49 如何唤醒处于wait状态的线程？可以使用notify()方法或notifyAll()方法来唤醒处于wait状态的线程。\n4.50 wait()方法和await()方法有什么区别？wait()方法是Object类的方法，用于线程的等待；await()方法是Condition接口中的方法，用于线程的等待指定条件满足。\n4.51 为什么使用notifyAll()方法而不是notify()方法？使用notifyAll()方法可以通知所有等待该对象锁的线程，确保不会有线程被遗漏。\n4.52 如何防止线程的等待超时？可以使用wait()方法的重载版本**wait(long timeout)**来设置等待的超时时间。\n4.53 为什么wait()方法和notify()方法定义在Object类中而不是Thread类中？wait()方法和notify()方法定义在Object类中是因为每个对象都拥有一个锁和一个等待集，而线程只是操作对象的锁和等待集。\n4.54 为什么wait()方法和notify()方法被定义为final？wait()方法和notify()方法被定义为final，是为了防止子类对其进行重写。\n4.55 wait()方法和notify()方法会释放线程所拥有的锁吗？是的，调用wait()方法后，线程会释放它所拥有的锁，以供其他线程竞争。\n4.56 能否在非同步方法中调用wait()方法和notify()方法？不可以，在非同步方法中调用这些方法会抛出IllegalMonitorStateException异常。\n4.57 如何使用notify()方法和wait()方法实现线程间的协作？可以使用生产者-消费者模式，通过notify()方法唤醒消费者线程，然后消费者线程在消费完成后调用wait()方法等待生产者线程的唤醒。\n4.58 在多线程环境下，如何保证两个线程交替执行？可以使用wait()方法和notify()方法结合使用，让线程在合适的时机等待并唤醒。 \n4.59 什么是CAS锁？CAS锁可以保证原子性，思想是更新内存时会判断内存值是否被别人修改过，如果没有就直接更新。如果被修改，就重新获取值，直到更新完成为止。这样的缺点是\n（1）只能支持一个变量的原子操作，不能保证整个代码块的原子操作\n（2）CAS频繁失败导致CPU开销大\n（3）ABS问题:线程1和线程2同时去修改一个变量，将值从A改为B，但线程1突然阻塞，此时线程2将A改为B,然后线程3又将B改成A,此时线程1将A又改为B,这个过程线程2是不知道的，这就是ABA问题，可以通过版本号或时间戳解决\n4.60 Synchronized锁原理和优化？Synchronize是通过对象头的markwordk来表明监视器的，监视器本质是依赖操作系统的互斥锁实现的。操作系统实现线程切换要从用户态切换为核心态，成本很高，此时这种锁叫重量级锁，在JDK1.6以后引入了偏向锁、轻量级锁、重量级锁。这里的锁优化主要是指虚拟机对 synchronized 的优化。\n4.60.1 自旋锁互斥同步的进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。\n自选锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。\n4.60.2 锁消除锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。\n锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。\n对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：\n1public static String concatString(String s1, String s2, String s3) &#123; return s1 + s2 + s3; &#125;\n\nString 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：\n1234567public static String concatString(String s1, String s2, String s3) &#123;    StringBuffer sb = new StringBuffer();    sb.append(s1);    sb.append(s2);    sb.append(s3);        return sb.toString();&#125;\n\n每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会“逃逸”到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。\n4.60.3 锁粗化如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。\n上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。\n4.59.4 轻量级锁轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。\n如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。\n4.59.5 偏向锁偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。\n当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。\n当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。\n注意，锁只能升级不能降级\n4.61 synchronized 和 ReentrantLock 比较\n锁的实现：synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。\n\n性能：新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等。目前来看它和 ReentrantLock 的性能基本持平了，因此性能因素不再是选择 ReentrantLock 的理由。synchronized 有更大的性能优化空间，应该优先考虑 synchronized。\n\n功能：ReentrantLock 多了一些高级功能。\n\n使用选择：除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。\n\n\n4.62 join()方法和yield()方法用途及原理?yield()和join()区别用途及原理：\nThread.join方法用于让一个线程等待另一个线程执行完毕，原理是调用线程的join方法后，当前线程会阻塞，直到被调用join方法的线程执行完毕。插队\nThread.yield方法用于让当前线程主动让出CPU时间片，让其他具有相同优先级的线程有机会执行，尽量平衡各个线程的执行。让它插队\n区别：\nyield()调用后线程进入就绪状态\nA线程中调用B线程的join() ,则B执行完前A进入阻塞状态\n4.63 Java内存模型JMM（Java内存模型 ）屏蔽了各种硬件和操作系统的内存访问差异，实现让Java程序在各平台下都能达到一致的内存访问效果，它定义了JVM如何将程序中的变量在主存中读取\n具体定义为：所有变量都存在主存中，主存是线程共享区域；每个线程都有自己独有的工作内存，线程想要操作变量必须从主存中copy变量到自己的工作区，每个线程的工作内存是相互隔离的\n由于主存与工作内存之间有读写延迟，且读写不是原子性操作，所以会有线程安全问题\n4.64 保证并发安全的三大特性？原子性：一次或多次操作在执行期间不被其他线程影响，操作不可被中断，要么全部执行成功，要么全部不执行\n可见性：当一个线程在工作内存修改了变量，其他线程能立刻知道\n有序性：有序性是指程序执行的顺序按照代码的先后顺序执行，JVM对指令的优化会让指令执行顺序改变，有序性是禁止指令重排\n4.65 JUC是什么？JUC常用辅助类？JUC：Java Util Concurrency，是Java并发工具包的缩写，提供了一些并发编程中常用的工具类和接口。\n常用辅助类：\nCountDownLatch:设定一个数，当调用CountDown()时数量减一，当调用await() 时判断计数器是否为0，不为0就阻塞，直到计数器为0\nCyclicBarrier：设定一个数,当调用await() 时判断计数器是否达到目标值，未达到就阻塞，直到计数器达到目标值\nSemaphore:设定一个信号量，当调用acquire()时判断是否还有信号，有就信号量减一线程继续执行，没有就阻塞等待其他线程释放信号量，当调用release()时释放信号量，唤醒阻塞线程\n4.66 如何根据 CPU 核心数设计线程池线程数量IO 密集型：核心数*2\n计算密集型： 核心数+1\n为什么加 1？即使当计算密集型的线程偶尔由于缺失故障或者其他原因而暂停时，这个额外的线程也能确保 CPU 的时钟周期不会被浪费。\n5. 集合5.1 Java集合框架常见的集合？可随机访问的集合类？常见的集合主要有以下几种：\n\nList结构的集合类：ArrayList类、LinkedList类、Vector类、Stack类。\nMap结构的集合类：HashMap类、Hashtable类。\nSet结构的集合类：HashSet类、TreeSet类。\nQueue结构的集合：Queue接口。\n\n可对元素进行随机访问的集合类有：ArrayList、HashMap、TreeMap和Hashtable。\n5.2 List接口的特点是什么？List是有序可重复的集合，允许存储多个相同的元素。\n5.3 Set接口的特点是什么？Set是无序不重复的集合，不允许存储重复的元素。\n5.4 Queue接口的特点是什么？Queue是一种队列数据结构，支持先进先出（FIFO）的操作。\n5.5 Map接口的特点是什么？为什么Map 接口不继承Collection接口？Map是键值对的映射，每个键只能对应一个值，不允许重复的键。Map接口不继承Collection接口的原因在于它们的用途和性质存在根本性的差异。Collection接口及其子接口（如List和Set）主要用于存储单一类型的元素，这些元素之间并没有直接的关联。而Map接口则主要用于存储键值对，即每个元素都是一个键和一个值的组合，它们之间存在直接的映射关系。因此，从设计上来说，Map接口与Collection接口并没有直接的继承关系。\n5.6 ArrayList和LinkedList的区别是什么？ArrayList是基于数组实现的，支持随机访问；LinkedList是基于双向链表实现的，支持快速插入和删除。\n5.7 HashSet和TreeSet的区别是什么？HashSet是基于哈希表实现的，元素无序且不重复；TreeSet是基于红黑树实现的，元素有序且不重复。\n5.8 HashMap和Hashtable的区别是什么？HashMap是非线程安全的，支持null键和null值；Hashtable是线程安全的，不允许有null键和null值。\n5.9 ConcurrentHashMap是什么？为何使用它？ConcurrentHashMap是线程安全的HashMap实现，适用于高并发场景。\n5.10 如何遍历一个集合？可以使用迭代器（Iterator）、for-each循环或者普通的for循环来遍历集合。\n5.11 什么是泛型（Generics）？泛型是Java中的一种参数化类型机制，提供了编译时类型安全检查和类型推断。\n5.12 什么是同步（Synchronized）和异步（Asynchronous）？同步是指多个线程按照一定的顺序执行；异步是指多个线程可以同时执行，无需等待。\n5.13 Collection和 Collections的区别？Collection和Collections的区别在于：Collection是一个接口，是Java集合框架的一部分，它代表了一组对象的集合。而Collections是Java的一个工具类，提供了许多静态方法，用于操作或返回集合对象。简单来说，Collection是集合框架中的接口，而Collections则是操作这些集合的实用工具类。\n5.14 如何将一个集合转换为数组？可以使用集合的toArray()方法将集合转换为数组。\n5.15 什么是fail-fast机制？在使用迭代器遍历集合的过程中，如果集合的结构发生了改变，会抛出ConcurrentModificationException异常，保证遍历的安全性。\n5.15 ArrayList和Vector的区别是什么？ArrayList是非线程安全的；Vector是线程安全的。\n5.16 什么是优先队列（PriorityQueue）？优先队列是一种特殊的队列，元素按照优先级顺序排序，并且每次取出的元素是优先级最高的。\n5.17 Java集合中的HashMap如何处理哈希冲突？HashMap使用链地址法解决哈希冲突，即在哈希桶中使用链表或红黑树来存储冲突的元素。\n5.18 什么是IdentityHashMap？IdentityHashMap是根据对象的引用相等性（而非equals方法）来判断键值对是否相等的Map实现。\n5.19 如何避免在使用集合时出现并发修改异常（ConcurrentModificationException）？可以使用并发集合类，如ConcurrentHashMap，或者使用迭代器的remove方法来避免并发修改异常。\n5.20 HashSet和HashMap之间有什么关联？HashSet实际上是基于HashMap实现的，只使用了HashMap的键，而值都是同一个对象。\n5.21 LinkedHashMap是什么？有什么特点？LinkedHashMap是继承自HashMap的Map实现，除了具有HashMap的特点外，还保留了插入顺序或访问顺序。\n5.22 TreeSet是如何保持元素有序性的？TreeSet使用红黑树作为底层数据结构来实现，保持元素有序。\n5.23 HashMap和TreeMap的区别是什么？HashMap是无序的，元素的顺序是无法保证的；TreeMap是有序的，元素按照键的自然顺序或指定的比较器顺序排列。\n5.24 HashSet如何保证元素不重复？HashSet使用hashCode和equals方法来判断元素的唯一性，如果hashCode相同且equals方法返回true，则认为是重复元素。\n5.25 如何使用Collections类对集合进行排序？可以使用Collections类的sort方法来对集合进行排序。\n5.26 如何实现自定义比较器（Comparator）？Comparable和Comparator接口的区别？可以实现Comparator接口，并重写compare方法来定义自定义比较器。\n区别：\n\nComparable：这是一个对象本身就已经支持自比较所需要实现的接口。例如，String、Integer、Float、Double等类型已经实现了Comparable接口，因此它们可以自然地进行比较大小操作。自定义的类如果想要在加入list容器后能够排序，可以实现Comparable接口。\nComparator：这是一个专用的比较器，主要在集合外部实现排序。当对象不支持自比较或自比较函数不能满足需求时，可以编写一个Comparator来完成两个对象之间大小的比较。使用Comparator是一种策略模式，即不改变对象自身，而用一个策略对象来改变它的行为。\n\n5.27 什么是弱引用（WeakReference）和软引用（SoftReference）？弱引用和软引用都可以在内存不足时被垃圾回收器回收，但软引用的回收策略相对宽松一些。\n5.28 Java集合框架中如何保证线程安全？可以使用使用线程安全的集合类，如ConcurrentHashMap、CopyOnWriteArrayList等。\n5.29 ConcurrentHashMap是如何保证线程安全的？ConcurrentHashMap使用了分段锁（Segment）来提高并发访问的效率和线程安全性。具有类似HashMap的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。\n不过JDK8之后，ConcurrentHashMap舍弃了ReentrantLock，而重新使用了synchronized。其原因大致有一下几点：\n\n加入多个分段锁浪费内存空间。\n生产环境中， map 在放入时竞争同一个锁的概率非常小，分段锁反而会造成更新等操作的长时间等待。\n为了提高 GC 的效率\n\n新的ConcurrentHashMap中使用synchronized关键字+CAS操作保证了线程安全。\n5.30 什么是CAS？CAS全称Compare and Swap，即比较并替换。\nCAS本质上很简单，一般至少有3个参数：一个变量v，旧值A，新值B。当且仅当变量v当前的值和旧值A相同时，才会将v的值更新为B。这整个操作是原子化的，不同平台的JVM也有不同的实现，一般以Native方法执行。\n5.31 什么是CopyOnWriteArrayList？CopyOnWriteArrayList是一种线程安全的ArrayList实现，通过在写操作时复制整个集合来实现线程安全。\n5.32 Java集合框架中有没有用于存储有序键值对的容器？是的，TreeMap是用于存储有序键值对的容器。\n5.33 Java中的ConcurrentSkipListMap是什么？ConcurrentSkipListMap是一种线程安全的有序映射表，内部通过跳表实现。\n5.34 跳表是什么？跳表，又叫做跳跃表、跳跃列表，在有序链表的基础上增加了“跳跃”的功能跳表在原来的有序链表上加上了多级索引，通过索引来快速查找；可以支持快速的删除、插入和查找操作。跳表实际上是一种增加了前向指针的链表，是一种随机化的数据结构Redis中 的 SortedSet、LevelDB 中的 MemTable 都用到了跳表对比平衡树, 跳表的实现和维护会更加简单, 跳表的搜索、删除、添加的平均时间复杂度是 O(logn)\n5.35 Java集合框架中的阻塞队列BlockingQueue是什么？Java集合框架中有没有用于线程间数据传输的容器？BlockingQueue是一种支持阻塞操作的队列，可以在队列为空或队列满时进行阻塞等待。BlockingQueue是用于线程间通信的容器，例如ArrayBlockingQueue、LinkedBlockingQueue等。\n5.36 Java集合框架中如何实现自定义的哈希函数？可以通过重写对象的hashCode方法来实现自定义的哈希函数。\n5.37 什么是并发容器（Concurrent Collections）？并发容器是一组线程安全的容器类，在多线程环境下使用更加安全和高效，如ConcurrentHashMap、ConcurrentLinkedQueue等。\n5.38 Java中哪个集合类是线程安全的？Vector、Hashtable、ConcurrentHashMap等是线程安全的集合类。\n5.39 为什么要使用同步容器而不是并发容器？同步容器在单线程环境下效率更高，而并发容器在多线程环境下更安全和高效。\n5.40 Java集合框架中如何实现线程安全的栈（Stack）？可以使用线程安全的集合类，如ConcurrentLinkedDeque等来实现线程安全的栈。\n5.41 HashSet和HashMap中元素的存储原理是怎样的？HashSet和HashMap都使用了哈希表存储元素，通过元素的hashCode来确定其在哈希表中的位置。\n5.42 HashSet中允许存储空元素吗？是的，HashSet允许存储一个null元素。\n5.43 如果两个对象的equals方法返回true，则它们的哈希码一定相等吗？是的，根据equals和hashCode的规范，相等的对象必须具有相同的哈希码。\n5.44 为什么需要使用泛型？使用泛型可以增加代码的类型安全性、可读性和重用性，避免了强制类型转换的问题。\n5.45 通配符在泛型中的作用是什么？通配符（Wildcard）用于表示未知类型，在泛型的参数、返回值和集合中使用。\n5.46 什么是限定通配符（Bounded Wildcards）？限定通配符是指在通配符上加上上限或下限来限制泛型类型的范围。\n5.47 什么是类型擦除（Type Erasure）？类型擦除是指在编译时会将泛型类型擦除成原始类型，以保持与旧版本Java的兼容性。\n5.48 如何在泛型中使用继承关系？可以使用extends关键字表示泛型的上限，或使用super关键字表示泛型的下限。\n5.49 Java中的泛型方法是什么？泛型方法是指在声明方法时使用泛型类型参数的方法。\n5.50 泛型和数组有什么区别？数组可以存储任意类型的元素，而泛型则可以在编译时进行类型检查，并提供类型安全的操作。\n5.51 什么是泛型类和泛型方法的区别？泛型类是在类级别上使用泛型类型参数，泛型方法是在方法级别上使用泛型类型参数。\n5.52 什么是泛型擦除（Type Erasure）的具体行为？在编译时，泛型类型参数会被擦除为其边界或Object类型，并插入类型转换操作。\n5.53 可以创建泛型数组吗？Java不允许创建具有泛型类型参数的数组，可以使用集合或Object数组代替。\n5.54 泛型在运行时是否保留类型信息？泛型的类型信息在运行时会被擦除，无法直接访问类型参数的具体类型。\n5.55 如何在泛型中使用可变参数（Varargs）？可以在泛型方法中使用可变参数，类似于普通方法的使用方式。\n注意：java方法的变长参数只是语法糖，其本质上还是将变长的实际参数 varargs包装为一个数组。\n所以 Object[] objs 与 Object… objs 被看作是相同的签名，在源码级别是不能同时存在的，否则无法编译通过。\n123456// 泛型方法，接收可变参数    public static &lt;T&gt; void printArray(T... args) &#123;        for (T arg : args) &#123;            System.out.println(arg);        &#125;    &#125;\n\n5.56 为什么选择这种实现机制？不擦除不行么？在Java诞生10年后，才想实现类似于C++模板的概念，即泛型。Java的类库是Java生态中非常宝贵的财富，必须保证向后兼容（即现有的代码和类文件依旧合法）和迁移兼容（泛化的代码和非泛化的代码可互相调用）基于上面这两个背景和考虑，Java设计者采取了“类型擦除”这种折中的实现方式。\n5.57 在泛型中如何进行类型转换？可以使用类型参数的instanceof操作符进行类型检查，并使用强制类型转换进行类型转换。  \n5.58集合使用泛型有什么优点？\n保证类型安全：泛型可以约束变量的类型，确保在集合中只能添加特定类型的元素。\n提高性能：泛型变量在声明时已经确定了类型，避免了运行时的装箱和拆箱操作，从而提高了程序的性能。\n提高代码复用性：泛型允许我们编写可以处理多种数据类型的代码，提高了代码的复用性。\n\n5.59 Enumeration和 Iterator接口的区别？\nEnumeration是一个较早期的接口，用于枚举集合中的元素。然而，它已经被Iterator接口所取代，因为Iterator提供了更强大的功能。\nIterator接口允许在迭代期间从迭代器所指向的集合中移除元素，并改进了方法名称。尽管Enumeration接口没有被完全废弃，但在新程序中，建议使用Iterator接口。\n\n6. 注解6.1 什么是注解？注解是一种特殊的标记，在编程中用来提供额外的信息给编译器、解释器或其他编程工具。\n6.2 Java中的注解有什么作用？Java中的注解可以用于描述类、方法、字段等元素的属性、行为和约束，为编写优雅、可读性高的代码提供支持。\n6.3 如何定义一个注解？可以使用@interface关键字定义一个注解，注解的成员变量可以用来存储元数据。\n6.4 注解可以用在哪些地方？注解可以用在类、方法、字段、参数等地方。\n6.5 如何使用Java中的内置注解？可以直接在使用的地方加上相应的注解，如@Override、@Deprecated等。\n6.6 如何使用自定义注解？需要在注解上添加元注解@Retention(RetentionPolicy.RUNTIME)，然后可以在目标元素上使用该注解。\n6.7 注解的生命周期有几种？注解的生命周期有3种：源码级别（SOURCE）、编译期级别（CLASS）和运行时级别（RUNTIME）。\n6.8 如何通过反射获取注解信息？可以使用Class对象的getAnnotation()或getAnnotations()方法来获取指定注解或所有注解。\n6.9 注解的元数据可以用来做什么？注解的元数据可以用来配置程序的行为、生成文档、进行代码分析等。\n6.10 如何在注解中定义成员变量？可以在注解中定义成员变量，并使用默认值为其指定初始值。\n6.11 注解的成员变量可以是什么类型？注解的成员变量可以是基本类型、字符串、枚举、注解、Class对象以及它们的数组。\n6.12 如何为注解的成员变量指定值？可以使用注解时的”key&#x3D;value“格式为注解的成员变量指定值。\n6.13 如何在程序中处理注解？可以使用反射来处理注解，读取注解的元数据并进行相应的处理。\n6.14 在注解中可以继承其他注解吗？在Java中，注解不能继承其他注解。\n6.15 注解的声明周期可以通过什么设置？可以通过**@Retention元注解**来设置注解的声明周期。\n6.16 如何在运行时获取注解的元数据？需要使用反射来获取注解的元数据，通过Class对象或其他反射API来操作。\n6.17 注解与反射机制有何关系？注解和反射机制是密切相关的，通过反射可以获取注解的元数据，并根据注解来进行相应的操作。\n6.18 注解在框架开发中有何应用？注解在框架开发中可以用于配置文件的映射、依赖注入、AOP等方面，提供更灵活和轻量级的开发方式。\n6.19 如何定义一个注解的元注解？可以使用@interface关键字来定义一个注解的元注解。\n6.20 你在项目中用过哪些常见的注解？常见的注解有：@Override、@Deprecated、@SuppressWarnings、@Autowired等。\n","slug":"JavaSE面试问题总结——答案版","date":"2024-03-19T08:08:30.000Z","categories_index":"","tags_index":"八股","author_index":"Fausto Wu"},{"id":"55c312fa2e77afdfd966e3f29479617e","title":"Redis面试问题总结——答案版","content":"1. 常规问题1.1 什么是Redis，为什么用Redis？Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。\n• 读写性能优异：Redis能读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s （测试条件见下一节）。\n• 数据类型丰富：Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。\n• 原子性：Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。\n• 丰富的特性：Redis支持 publish&#x2F;subscribe, 通知, key 过期等特性。\n• 持久化：Redis支持RDB, AOF等持久化方式\n• 发布订阅：Redis支持发布&#x2F;订阅模式\n• 分布式：Redis Cluster\n1.2. 为什么Redis 是单线程的以及为什么这么快？• redis完全基于内存,绝大部分请求是纯粹的内存操作,非常快速.\n• 数据结构简单,对数据操作也简单,redis中的数据结构是专门进行设计的\n• 采用单线程模型, 避免了不必要的上下文切换和竞争条件, 也不存在多线程或者多线程切换而消耗CPU, 不用考虑各种锁的问题, 不存在加锁, 释放锁的操作, 没有因为可能出现死锁而导致性能消耗\n• 使用了多路IO复用模型,非阻塞IO\n• 使用底层模型不同,它们之间底层实现方式及与客户端之间的通信的应用协议不一样,Redis直接构建了自己的VM机制,因为一般的系统调用系统函数的话,会浪费一定的时间去移动和请求\n1.2.1 阻塞IO模型（blocking I&#x2F;O）场景描述        点完餐后，不知道什么时候能做好，只好坐在餐厅里面等，直到做好，然后吃完才离开。但是不知道饭能什么时候做好，只好在餐厅等，而不能去逛街，直到吃完饭才能去逛街，中间等待做饭的时间浪费掉了。这就是典型的阻塞。\n优点：\n能够及时返回数据，无延迟；对内核开发者来说这是省事了；\n缺点：对用户来说处于等待就要付出性能的代价了；\n1.2.2 非阻塞IO模型（nonblocking I&#x2F;O）场景描述        我女友不甘心白白在这等，又想去逛商场，又担心饭好了。所以我们逛一会，回来询问服务员饭好了没有，来来回回好多次，饭都还没吃都快累死了啦。这就是非阻塞。需要不断的询问，是否准备好了。\n同步非阻塞就是 “每隔一会儿瞄一眼进度条” 的轮询（polling）方式。所以，非阻塞 IO的特点是用户进程需要不断的主动询问kernel数据好了没有。\n优点：能够在等待任务完成的时间里干其他活了（包括提交其他任务，也就是 “后台” 可以有多个任务在同时执行）。\n缺点：任务完成的响应延迟增大了，因为每过一段时间才去轮询一次read操作，而任务可能在两次轮询之间的任意时间完成。这会导致整体数据吞吐量的降低。\n1.2.3 IO多路复用模型（I&#x2F;O multiplexing）场景描述        与第二个方案差不多，餐厅安装了电子屏幕用来显示点餐的状态，这样我和女友逛街一会，回来就不用去询问服务员了，直接看电子屏幕就可以了。这样每个人的餐是否好了，都直接看电子屏幕就可以了，这就是典型的IO多路复用。\nI&#x2F;O多路复用的主要应用场景如下：\n服务器需要同时处理多个处于监听状态或者多个连接状态的套接字。服务器需要同时处理多种网络协议的套接字。在IO 多路复用模型中，对于每一个socket，一般都设置成为non-blocking，但是，整个用户的进程其实是一直被block的。只不过进程是被select这个函数block，而不是被socket IO给block。所以IO多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I&#x2F;O系统调用上。\n1.3. Redis 一般有哪些使用场景？可以结合自己的项目讲讲，比如\n• 热点数据的缓存：缓存是Redis最常见的应用场景，之所有这么使用，主要是因为Redis读写性能优异。而且逐渐有取代**memcached**，成为首选服务端缓存的组件。而且，Redis内部是支持事务的，在使用时候能有效保证数据的一致性。\n• 限时业务的运用：redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。\n• 计数器相关问题：redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。\n• 分布式锁：这个主要利用redis的setnx命令进行，setnx：”set if not exists”就是如果不存在则成功设置缓存同时返回1，否则返回0 ，这个特性在集群的服务器中有所运用，定时任务可能在两台机器上都会运行，所以在定时任务中首先通过setnx设置一个lock，如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。在分布式锁的场景中，主要用在比如秒杀系统等。\n2. 数据类型和数据结构2.1 Redis 有哪些数据类型？ 5种基础数据类型，分别是：String、List、Set、Zset、Hash。\n结构类型结构存储的值结构的读写能力String字符串可以是字符串、整数或浮点数对整个字符串或字符串的一部分进行操作；对整数或浮点数进行自增或自减操作；List列表一个链表，链表上的每个节点都包含一个字符串对链表的两端进行push和pop操作，读取单个或多个元素；根据值查找或删除元素；Set集合包含字符串的无序集合字符串的集合，包含基础的方法有看是否存在添加、获取、删除；还包含计算交集、并集、差集等；Hash散列包含键值对的无序散列表包含方法有添加、获取、删除单个元素；Zset有序集合和散列一样，用于存储键值对字符串成员与浮点数分数之间的有序映射；元素的排列顺序由分数的大小决定；包含方法有添加、获取、删除单个元素以及根据分值范围或成员来获取元素\n• 三种特殊的数据类型 分别是 HyperLogLogs（基数统计）， Bitmaps (位图) 和 geospatial （地理位置) \n2.2 谈谈Redis 的对象机制（redisObject)？比如说， 集合类型就可以由字典和整数集合两种不同的数据结构实现， 但是， 当用户执行 ZADD 命令时， 他&#x2F;她应该不必关心集合使用的是什么编码， 只要 Redis 能按照 ZADD 命令的指示， 将新元素添加到集合就可以了。\n这说明, 操作数据类型的命令除了要对键的类型进行检查之外, 还需要根据数据类型的不同编码进行多态处理.\n为了解决以上问题, Redis 构建了自己的类型系统, 这个系统的主要功能包括:\n• redisObject 对象.\n• 基于 redisObject 对象的类型检查.\n• 基于 redisObject 对象的显式多态函数.\n• 对 redisObject 进行分配、共享和销毁的机制. \n2.3 Redis 数据类型有哪些底层数据结构？• 简单动态字符串 - sds\n• 压缩列表 - ZipList\n• 快表 - QuickList\n• 字典&#x2F;哈希表 - Dict\n• 整数集 - IntSet\n• 跳表 - ZSkipList\n2.4 为什么要设计sds？定义：Redis中的SDS（Simple Dynamic Strings）是一种用于表示字符串的内部数据结构。\n123456struct sdshdr &#123;    int len; /* 存储字符串的长度 */    int alloc; /* 已经分配的总长度 */    unsigned char flags; /* 存的这个结构的类型,其中的最低3个bit用来表示header的类型,剩余5位未使用 */    char buf[]; /* 一个c字符串,用来存储真实的字符串 */&#125;;\n\n• 常数复杂度获取字符串长度\n由于 len 属性的存在，我们获取 SDS 字符串的长度只需要读取 len 属性，时间复杂度为 O(1)。而对于 C 语言，获取字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。通过 strlen key 命令可以获取 key 的字符串长度。\n• 杜绝缓冲区溢出\n我们知道在 C 语言中使用 strcat 函数来进行两个字符串的拼接，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。而对于 SDS 数据类型，在进行字符修改的时候，会首先根据记录的 len 属性检查内存空间是否满足需求，如果不满足，会进行相应的空间扩展，然后在进行修改操作，所以不会出现缓冲区溢出。\n• 减少修改字符串的内存重新分配次数\nC语言由于不记录字符串的长度，所以如果要修改字符串，必须要重新分配内存（先释放再申请），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。\n而对于SDS，由于len属性和alloc属性的存在，对于修改字符串SDS实现了空间预分配和惰性空间释放两种策略：\n惰性空间，就像人具有懒惰性一样，空间的分配也可以具有懒惰性，简单说，如果Chunk在刚开始没有分配这么多空间，而是在需要的时候按需进行扩容，这种方法既节省了空间的浪费，也使得内部造成的碎片不会太多。\n\n空间预分配：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。\n\n惰性空间释放：对字符串进行缩短操作时，程序不立即使用内存重新分配来回收缩短后多余的字节，而是使用 alloc 属性将这些字节的数量记录下来，等待后续使用。（当然SDS也提供了相应的API，当我们有需要时，也可以手动释放这些未使用的空间。）\n\n\n• 二进制安全\n因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取；而所有 SDS 的API 都是以处理二进制的方式来处理 buf 里面的元素，并且 SDS 不是以空字符串来判断是否结束，而是以 len 属性表示的长度来判断字符串是否结束。\n• 兼容部分 C 字符串函数\n虽然 SDS 是二进制安全的，但是一样遵从每个字符串都是以空字符串结尾的惯例，这样可以重用 C 语言库&lt;string.h&gt; 中的一部分函数。 \n2.5 Redis 一个字符串类型的值能存储最大容量是多少？512M\n2.6 为什么会设计Stream？Redis引入Stream是为了支持更高级别的数据结构和操作，以满足现代应用中越来越复杂的需求。Stream是一种新型的数据结构，可以轻松地实现类似消息队列、日志引擎等功能。用过Redis做消息队列的都了解，基于Reids的消息队列实现有很多种，例如：\n• PUB&#x2F;SUB，订阅&#x2F;发布模式\nRedis发布&#x2F;订阅（Pub&#x2F;Sub）是一种通信机制，将数据推到某个信息管道中，其他客户端可通过订阅这些管道来获取推送信息，以此用于消息的传输。由三部分组成：发布者（Publisher）、频道（Channel）、订阅者（Subscriber）。\n​\t但是发布订阅模式是无法持久化的，如果出现网络断开、Redis 宕机等，消息就会被丢弃；\n• 基于List LPUSH+BRPOP 或者 基于Sorted-Set 的实现\n\n使用LPUSH和BRPOP命令：LPUSH命令用于将一个或多个值插入到列表头部。BRPOP命令是RPOP的阻塞版本，它会移除并获得列表的最后一个元素，如果列表没有元素会阻塞列表直到等待时间超时或者收到一个元素。\n使用Sorted Set和BZPOPMAX命令：ZADD命令用于将一个或多个成员元素及其分数值加入到有序集当中。BZPOPMAX是ZPOPMAX的阻塞版本，它会移除并获取有序集合中分数最大的元素，如果有序集合为空，那么命令会阻塞，直到有元素添加到有序集合中或者指定的超时时间发生。\n\n​\t支持了持久化，但是不支持多播，分组消费等\n2.7 Redis Stream用在什么样场景？可用作时通信等，大数据分析，异地数据备份等\n客户端可以平滑扩展，提高处理能力\n2.8 Redis Stream消息ID的设计是否考虑了时间回拨的问题？Redis生成的消息ID，由两部分组成:时间戳-序号。时间戳是毫秒级单位，是生成消息的Redis服务器时间，它是个64位整型（int64）。序号是在这个毫秒时间点内的消息序号，它也是个64位整型。\n可以通过multi批处理，来验证序号的递增：\n由于一个redis命令的执行很快，所以可以看到在同一时间戳内，是通过序号递增来表示消息的。\n为了保证消息是有序的，因此Redis生成的ID是单调递增有序的。由于ID中包含时间戳部分，为了避免服务器时间错误而带来的问题（例如服务器时间延后了），Redis的每个Stream类型数据都维护一个latest_generated_id属性，用于记录最后一个消息的ID。若发现当前时间戳退后（小于latest_generated_id所记录的），则采用时间戳不变而序号递增的方案来作为新消息ID（这也是序号为什么使用int64的原因，保证有足够多的的序号），从而保证ID的单调递增性质。\n强烈建议使用Redis的方案生成消息ID，因为这种时间戳+序号的单调递增的ID方案，几乎可以满足你全部的需求。但同时，记住ID是支持自定义的，别忘了！ \n2.9 Redis Stream消费者崩溃带来的会不会消息丢失问题?为了解决组内消息读取但处理期间消费者崩溃带来的消息丢失问题，STREAM 设计了 Pending 列表，用于记录读取但并未处理完毕的消息。命令XPENDIING 用来获消费组或消费内消费者的未处理完毕的消息。\n每个Pending的消息有4个属性：\n• 消息ID\n• 所属消费者\n• IDLE，已读取时长\n• delivery counter，消息被读取次数\n若消息被记录在Pending列表中，说明全部读到的消息都没有处理，仅仅是读取了。那如何表示消费者处理完毕了消息呢？使用命令 XACK 完成告知消息处理完成，演示如下：\n有了这样一个Pending机制，就意味着在某个消费者读取消息但未处理后，消息是不会丢失的。等待消费者再次上线后，可以读取该Pending列表，就可以继续处理该消息了，保证消息的有序和不丢失。\n2.10 Redis Steam 坏消息问题，死信问题?正如上面所说，如果某个消息，不能被消费者处理，也就是不能被XACK，这是要长时间处于Pending列表中，即使被反复的转移给各个消费者也是如此。此时该消息的delivery counter就会累加（上一节的例子可以看到），当累加到某个我们预设的临界值时，我们就认为是坏消息（也叫死信，DeadLetter，无法投递的消息），由于有了判定条件，我们将坏消息处理掉即可，删除即可。删除一个消息，使用XDEL语法。\n3. 持久化和内存3.1 Redis 的持久化机制是什么？各自的优缺点？一般怎么用？\nRDB持久化是把当前进程数据生成快照保存到磁盘上的过程; 针对RDB不适合实时持久化的问题，Redis提供了AOF持久化方式来解决.\n\nAOF是“写后”日志，Redis先执行命令，把数据写入内存，然后才记录日志。日志里记录的是Redis收到的每一条命令，这些命令是以文本形式保存。\n\nRedis 4.0 中提出了一个混合使用 AOF 日志和内存快照的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。\n\n\n这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。\n这个方法既能享受到 RDB 文件快速恢复的好处，又能享受到 AOF 只记录操作命令的简单优势, 实际环境中用的很多。 \n3.2 RDB 触发方式?触发rdb持久化的方式有2种，分别是手动触发和自动触发。\n3.2.1 手动触发• save命令：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存 比较大的实例会造成长时间阻塞，线上环境不建议使用\n• bgsave命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短 \n3.2.2 自动触发• redis.conf中配置save m n，即在m秒内有n次修改时，自动触发bgsave生成rdb文件；\n• 主从复制时，从节点要从主节点进行全量复制时也会触发bgsave操作，生成当时的快照发送到从节点；\n• 执行debug reload命令重新加载redis时也会触发bgsave操作；\n• 默认情况下执行shutdown命令时，如果没有开启aof持久化，那么也会触发bgsave操作；\n3.3 那么如何保证数据一致性呢？RDB由于生产环境中我们为Redis开辟的内存区域都比较大（例如6GB），那么将内存中的数据同步到硬盘的过程可能就会持续比较长的时间，而实际情况是这段时间Redis服务一般都会收到数据写操作请求。那么如何保证数据一致性呢？\nRDB中的核心思路是Copy-on-Write，来保证在进行快照操作的这段时间，需要压缩写入磁盘上的数据在内存中不会发生变化。在正常的快照操作中，一方面Redis主进程会fork一个新的快照进程专门来做这个事情，这样保证了Redis服务不会停止对客户端包括写请求在内的任何响应。另一方面这段时间发生的数据变化会以副本的方式存放在另一个新的内存区域，待快照操作结束后才会同步到原来的内存区域。\n举个例子：如果主线程对这些数据也都是读操作，那么，主线程和 bgsave 子进程相互不影响。但是，如果主线程要修改一块数据，那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。 \n3.4 在进行RDB快照操作的这段时间，如果发生服务崩溃怎么办？很简单，在没有将数据全部写入到磁盘前，这次快照操作都不算成功。如果出现了服务崩溃的情况，将以上一次完整的RDB快照文件作为恢复内存数据的参考。也就是说，在快照操作过程中不能影响上一次的备份数据。Redis服务会在磁盘上创建一个临时文件进行数据操作，待操作成功后才会用这个临时文件替换掉上一次的备份。\n3.5 可以每秒做一次RDB快照吗？对于快照来说，所谓“连拍”就是指连续地做快照。这样一来，快照的间隔时间变得很短，即使某一时刻发生宕机了，因为上一时刻快照刚执行，丢失的数据也不会太多。但是，这其中的快照间隔时间就很关键了。\n如下图所示，我们先在 T0 时刻做了一次快照，然后又在 T0+t 时刻做了一次快照，在这期间，数据块 5 和 9 被修改了。如果在 t 这段时间内，机器宕机了，那么，只能按照 T0 时刻的快照进行恢复。此时，数据块 5 和 9 的修改值因为没有快照记录，就无法恢复了。\n所以，要想尽可能恢复数据，t 值就要尽可能小，t 越小，就越像“连拍”。那么，t 值可以小到什么程度呢，比如说是不是可以每秒做一次快照？毕竟，每次快照都是由 bgsave 子进程在后台执行，也不会阻塞主线程。\n这种想法其实是错误的。虽然 bgsave 执行时不阻塞主线程，但是，如果频繁地执行全量快照，也会带来两方面的开销：\n• 一方面，频繁将全量数据写入磁盘，会带来很大的磁盘压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。\n• 另一方面，bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长。如果频繁 fork 出 bgsave 子进程，这就会频繁阻塞主线程了。\n那么，有什么其他好方法吗？此时，我们可以做增量快照，就是指做了一次全量快照后，后续的快照只对修改的数据进行快照记录，这样可以避免每次全量快照的开销。这个比较好理解。\n但是它需要我们使用额外的元数据信息去记录哪些数据被修改了，这会带来额外的空间开销问题。那么，还有什么方法既能利用 RDB 的快速恢复，又能以较小的开销做到尽量少丢数据呢？**RDB和AOF的混合方式(Redis4.0)**。\n3.6 AOF是写前日志还是写后日志？AOF日志采用写后日志，即先写内存，后写日志。\n3.6.1 为什么采用写后日志？Redis要求高性能，采用写日志有两方面好处：\n• 避免额外的检查开销：Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。\n• 不会阻塞当前的写操作\n但这种方式存在潜在风险：\n• 如果命令执行完成，写日志之前宕机了，会丢失数据。\n• 主线程写磁盘压力大，导致写盘慢，阻塞后续操作。 \n3.7 如何实现AOF的？AOF日志记录Redis的每个写命令，步骤分为：命令追加（append）、文件写入（write）和文件同步（sync）。\n• 命令追加 当AOF持久化功能打开了，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器的 aof_buf 缓冲区。\n• 文件写入和同步 关于何时将 aof_buf 缓冲区的内容写入AOF文件中，Redis提供了三种写回策略：\n\nAlways，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；\n\nEverysec，每秒写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；\n\nNo，操作系统控制的写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。\n\n\n3.8 三种写回策略的优缺点上面的三种写回策略体现了一个重要原则：trade-off，取舍，指在性能和可靠性保证之间做取舍。\n关于AOF的同步策略是涉及到操作系统的 write 函数和 fsync 函数的，在《Redis设计与实现》中是这样说明的\n为了提高文件写入效率，在现代操作系统中，当用户调用write函数，将一些数据写入文件时，操作系统通常会将数据暂存到一个内存缓冲区里，当缓冲区的空间被填满或超过了指定时限后，才真正将缓冲区的数据写入到磁盘里。\n这样的操作虽然提高了效率，但也为数据写入带来了安全问题：如果计算机停机，内存缓冲区中的数据会丢失。为此，系统提供了fsync、fdatasync同步函数，可以强制操作系统立刻将缓冲区中的数据写入到硬盘里，从而确保写入数据的安全性。\n3.9 什么是AOF重写？Redis通过创建一个新的AOF文件来替换现有的AOF，新旧两个AOF文件保存的数据相同，但新AOF文件没有了冗余命令。\n3.10 AOF重写会阻塞吗？AOF重写过程是由后台进程bgrewriteaof来完成的。主线程fork出后台的bgrewriteaof子进程，fork会把主线程的内存拷贝一份给bgrewriteaof子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。\n所以aof在重写时，在fork进程时是会阻塞住主线程的\n3.11 AOF日志何时会重写？有两个配置项控制AOF重写的触发：\nauto-aof-rewrite-min-size:表示运行AOF重写时文件的最小大小，默认为64MB。\nauto-aof-rewrite-percentage:这个值的计算方式是，当前aof文件大小和上一次重写后aof文件大小的差值，再除以上一次重写后aof文件大小。也就是当前aof文件比上一次重写后aof文件的增量大小，和上一次重写后aof文件大小的比值。\n3.12 AOF重写日志时，有新数据写入咋整？重写过程总结为：“一个拷贝，两处日志”。在fork出子进程时的拷贝，以及在重写时，如果有新数据写入，主线程就会将命令记录到两个aof日志内存缓冲区中。如果AOF写回策略配置的是always，则直接将命令写回旧的日志文件，并且保存一份命令至AOF重写缓冲区，这些操作对新的日志文件是不存在影响的。（旧的日志文件：主线程使用的日志文件，新的日志文件：bgrewriteaof进程使用的日志文件）\n而在bgrewriteaof子进程完成会日志文件的重写操作后，会提示主线程已经完成重写操作，主线程会将AOF重写缓冲中的命令追加到新的日志文件后面。这时候在高并发的情况下，AOF重写缓冲区积累可能会很大，这样就会造成阻塞，Redis后来通过Linux管道技术让aof重写期间就能同时进行回放，这样aof重写结束后只需回放少量剩余的数据即可。\n最后通过修改文件名的方式，保证文件切换的原子性。\n在AOF重写日志期间发生宕机的话，因为日志文件还没切换，所以恢复数据时，用的还是旧的日志文件。\n3.13 主线程fork出子进程的是如何复制内存数据的？fork采用操作系统提供的写时复制（copy on write）机制，就是为了避免一次性拷贝大量内存数据给子进程造成阻塞。fork子进程时，子进程时会拷贝父进程的页表，即虚实映射关系（虚拟内存和物理内存的映射索引表），而不会拷贝物理内存。这个拷贝会消耗大量cpu资源，并且拷贝完成前会阻塞主线程，阻塞时间取决于内存中的数据量，数据量越大，则内存页表越大。拷贝完成后，父子进程使用相同的内存地址空间。但主进程是可以有数据写入的，这时候就会拷贝物理内存中的数据。 \n3.14 在重写日志整个过程时，主线程有哪些地方会被阻塞？\nfork子进程时，需要拷贝虚拟页表，会对主线程阻塞。\n\n主进程有bigkey写入时，操作系统会创建页面的副本，并拷贝原有的数据，会对主线程阻塞。\n\n子进程重写日志完成后，主进程追加aof重写缓冲区时可能会对主线程阻塞。\n\n\n3.15 为什么AOF重写不复用原AOF日志？两方面原因：\n\n父子进程写同一个文件会产生竞争问题，影响父进程的性能。\n\n如果AOF重写过程中失败了，相当于污染了原本的AOF文件，无法做恢复数据使用。\n\n\n3.16 Redis 过期键的删除策略有哪些?在单机版Redis中，存在两种删除策略：\n• 惰性删除：服务器不会主动删除数据，只有当客户端查询某个数据时，服务器判断该数据是否过期，如果过期则删除。\n• 定期删除：服务器执行定时任务删除过期数据，但是考虑到内存和CPU的折中（删除会释放内存，但是频繁的删除操作对CPU不友好），该删除的频率和执行时间都受到了限制。\n在主从复制场景下，为了主从节点的数据一致性，从节点不会主动删除数据，而是由主节点控制从节点中过期数据的删除。由于主节点的惰性删除和定期删除策略，都不能保证主节点及时对过期数据执行删除操作，因此，当客户端通过Redis从节点读取数据时，很容易读取到已经过期的数据。\nRedis 3.2中，从节点在读取数据时，增加了对数据是否过期的判断：如果该数据已过期，则不返回给客户端；将Redis升级到3.2可以解决数据过期问题。\n3.17 Redis 内存淘汰算法有哪些?Redis共支持八种淘汰策略，分别是noeviction、volatile-random、volatile-ttl、volatile-lru、volatile-lfu、allkeys-lru、allkeys-random 和 allkeys-lfu 策略。\n怎么理解呢？主要看分三类看：\n3.17.1 不淘汰• noeviction （v4.0后默认的）\n3.17.2 对设置了过期时间的数据中进行淘汰• 随机：volatile-random\n• ttl：volatile-ttl\n• lru：volatile-lru\n• lfu：volatile-lfu\n3.17.3 全部数据进行淘汰• 随机：allkeys-random\n• lru：allkeys-lru\n• lfu：allkeys-lfu\nLRU算法：LRU 算法的全称是 Least Recently Used，按照最近最少使用的原则来筛选数据。这种模式下会使用 LRU 算法筛选设置了过期时间的键值对。\nRedis优化的LRU算法实现：Redis会记录每个数据的最近一次被访问的时间戳。在Redis在决定淘汰的数据时，第一次会随机选出 N 个数据，把它们作为一个候选集合。接下来，Redis 会比较这 N 个数据的 lru 字段，把 lru 字段值最小的数据从缓存中淘汰出去。通过随机读取待删除集合，可以让Redis不用维护一个巨大的链表，也不用操作链表，进而提升性能。\nLFU 算法：LFU 缓存策略是在 LRU 策略基础上，为每个数据增加了一个计数器，来统计这个数据的访问次数。当使用 LFU 策略筛选淘汰数据时，首先会根据数据的访问次数进行筛选，把访问次数最低的数据淘汰出缓存。如果两个数据的访问次数相同，LFU 策略再比较这两个数据的访问时效性，把距离上一次访问时间更久的数据淘汰出缓存。\nRedis的LFU算法实现：当 LFU 策略筛选数据时，Redis 会在候选集合中，根据数据 lru 字段的后 8bit 选择访问次数最少的数据进行淘汰。当访问次数相同时，再根据 lru 字段的前 16bit 值大小，选择访问时间最久远的数据进行淘汰。\nRedis 只使用了 8bit 记录数据的访问次数，而 8bit 记录的最大值是 255，这样在访问快速的情况下，如果每次被访问就将访问次数加一，很快某条数据就达到最大值255，可能很多数据都是255，那么退化成LRU算法了。所以Redis为了解决这个问题，实现了一个更优的计数规则，并可以通过配置项，来控制计数器增加的速度。\n3.18 Redis的内存用完了会发生什么？如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以配置内存淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。 \n3.19 Redis如何做内存优化？\n缩减键值对象: 缩减键（key）和值（value）的长度，\n\nkey长度：如在设计键时，在完整描述业务情况下，键值越短越好。\nvalue长度：值对象缩减比较复杂，常见需求是把业务对象序列化成二进制数组放入Redis。首先应该在业务上精简业务对象，去掉不必要的属性避免存储无效数据。其次在序列化工具选择上，应该选择更高效的序列化工具来降低字节数组大小。以JAVA为例，内置的序列化方式无论从速度还是压缩比都不尽如人意，这时可以选择更高效的序列化工具，如: protostuff，kryo等，下图是JAVA常见序列化工具空间压缩对比。\n\n共享对象池\n\n对象共享池指Redis内部维护[0-9999]的整数对象池。创建大量的整数类型redisObject存在内存开销，每个redisObject内部结构至少占16字节，甚至超过了整数自身空间消耗。所以Redis内存维护一个[0-9999]的整数对象池，用于节约内存。 除了整数值对象，其他类型如list,hash,set,zset内部元素也可以使用整数对象池。因此开发中在满足需求的前提下，尽量使用整数对象以节省内存。\n\n字符串优化\n\n编码优化\n\n控制key的数量\n\n\n3.20 Redis key 的过期时间和永久有效分别怎么设置？EXPIRE 和 PERSIST 命令\n3.21 Redis 中的管道有什么用？一次请求&#x2F;响应服务器能实现处理新的请求即使旧的请求还未被响应，这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。（类似于消息队列）\n这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多 POP3 协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。\n","slug":"Redis面试问题总结——答案版","date":"2024-03-18T13:00:00.000Z","categories_index":"","tags_index":"八股","author_index":"Fausto Wu"}]