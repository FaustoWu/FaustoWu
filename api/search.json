[{"id":"531f170567168922331d8060bfe590e6","title":"JavaSE面试问题总结——答案版","content":"1. 面向对象1.1 什么是面向对象编程？答：面向对象编程是一种程序设计思想，通过将问题抽象成对象，通过对象之间的交互和数据封装来实现程序逻辑。\n1.2 Java中的类和对象有什么区别？答：类是描述对象的模板，对象是类的实例。类定义了对象的属性和行为，而对象则具体地拥有这些属性和行为。\n1.3 什么是封装？为什么要使用封装？答：封装是将数据和方法包装在类中，并限制对数据的直接访问。封装可以隐藏内部细节，提供对外部的安全接口，并实现代码的重用和维护。\n1.4 什么是继承？有什么作用？答：继承是指子类继承父类的属性和方法。继承可以实现代码的重用，提高代码的可维护性和可扩展性。\n1.5 Java是否支持多继承？答：Java不支持多继承，一个类只能继承一个父类。但是Java支持接口的多实现，实现了多继承的效果。\n1.6 什么是多态？如何实现多态？答：多态是同一类型的对象在不同情况下表现出不同的行为。多态可以通过继承和接口的方式实现。父 父 &#x3D; new 子\n1.7 什么是抽象类？有什么作用？答：抽象类是不能被实例化的，它只能被继承。抽象类可以包含抽象方法和具体方法的定义，用于作为其他类的父类。\n1.8 什么是接口？有什么作用？答：接口是一组抽象方法的集合。接口定义了对象应该具备的行为，类可以实现（implements）接口来达到多继承的效果。\n1.9 Java中的构造方法有什么作用？答：构造方法是用于在创建对象时初始化对象的状态。它的名称与类名相同，没有返回类型。\n1.10 什么是重载和重写？答：重载发生在同一个类中，方法名相同、参数列表、返回类型、权限修饰符可以不同。重写发生在子类中，方法名相、参数列表、返回类型都相同，权限修饰符要大于父类方法，声明异常范围要小于父类方法，但是final和private修饰的方法不可重写。\n1.11 什么是静态方法和静态变量？答：静态方法和静态变量属于类级别，而不是对象级别。它们可以在类被加载时直接调用，无需创建对象。\n1.12 Java中如何实现数据的隐藏和封装？答：Java中通过访问控制修饰符（private、protected、public）来限制对类的属性和方法的访问。\n1.13 什么是内部类？有什么作用？答：内部类是定义在其他类内部的类。它可以访问外部类的成员，并提供了更好的封装性和代码组织性。\n1.14 什么是匿名类？答：匿名类是没有名字的内部类，它通常用于直接创建对象并重写父类或接口的方法。\n1.15 什么是单继承和多实现？答：Java中一个类只能继承一个父类，这称为单继承；但是一个类可以实现多个接口，称为多实现。\n1.16 Java中如何防止继承？答：通过将类声明为final，可以防止其他类继承该类。\n1.17  什么是对象的浅拷贝和深拷贝？答：浅拷贝是指复制对象时，简单地复制对象的引用；深拷贝是指复制对象时，复制对象的所有引用和对象本身。\n1.18 什么是重写equals()和hashCode()方法的作用？答：重写equals()方法可以定制对象之间的相等比较逻辑；重写hashCode()方法可以保证对象在哈希表中的正确存储和查找。\n1.19 什么是枚举类？答：枚举类是一种特殊的类，它限制对象的个数，并提供了更好的类型安全和代码可读性。\n1.20 super关键字和this关键字有何区别？答：super关键字用于访问父类的成员（属性和方法），this关键字用于访问当前对象的成员。 \n1.21 接口和抽象类的区别？（1）抽象类可以有构造方法，而接口没有；\n（2）抽象类可以有抽象方法和具体方法，接口只能有抽象方法；\n（3）抽象类的成员4种权限修饰符都可以修饰，接口只能用private。\n2. 异常2.1 Java中的异常分为哪几类？各自的特点是什么？答：Java中的异常可以分为可查异常（Checked Exception）、运行时异常（Runtime Exception）和错误（Error）三类。可查异常需要在代码中显式捕获或声明抛出，运行时异常可以选择捕获或声明抛出，错误通常是指虚拟机相关的问题，无法恢复。\n2.2 Java中的异常处理机制是什么？答：Java的异常处理机制使用try-catch-finally语句块来处理异常。try块用于包裹可能抛出异常的代码，catch块用于捕获和处理异常，finally块用于定义无论是否异常都需要执行的代码。\n2.3 描述一下try-catch-finally语句块的执行流程。答：当try块中的代码出现异常时，会立即跳转到对应的catch块进行处理。如果发现catch块中可以处理该异常，会执行相应的代码，然后继续执行finally块中的代码；如果没有匹配的catch块，当前方法会立即结束，异常会被抛给上一级调用者或者由虚拟机处理。不论是否发生异常，finally块中的代码总会被执行。\n2.4 throw和throws关键字的作用是什么？答：throw关键字用于主动抛出一个异常对象，可以在任何地方使用。throws关键字用于在方法上声明可能抛出的异常类型，告诉调用者需要处理这些异常。\n2.5 RuntimeException和Checked Exception有什么区别？答：RuntimeException是运行时异常，程序员可以选择捕获或声明抛出，但不强制要求。Checked Exception是可查异常，需要在代码中显式捕获或声明抛出。区别在于编译器是否会强制检查异常的处理。\n2.6 什么是异常链？答：①捕获一个异常后抛出另一个异常，②并且希望把原始异常的信息保存下来，这被称为异常链。所有Throwable的子类在构造器中都可以接受一个cause（因由）对象作为参数。这个cause就用来表示原始异常，这样通过把原始异常传递给新的异常，使得即使在当前位置创建并抛出了新的异常，也能通过这个异常链追踪到异常最初发生的位置。\n1234567891011121314151617181920212223242526import java.sql.SQLException;import java.sql.SQLIntegrityConstraintViolationException;public class TestMain &#123;    public static void throwSQLIntegrityConstraintViolationException() throws SQLIntegrityConstraintViolationException &#123;        throw new SQLIntegrityConstraintViolationException(&quot;exception-SQLIntegrityConstraintViolationException&quot;);    &#125;    public static void throwRuntimeException() &#123;        try &#123;            throwSQLIntegrityConstraintViolationException();        &#125; catch (SQLException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    public static void main(String[] args) &#123;        try &#123;            throwRuntimeException();        &#125;        catch (Exception e) &#123;            System.out.println(e.getCause());        &#125;    &#125;&#125;\n\n\n\n2.7 什么时候应该使用finally块？答：finally块一般用于执行无论是否发生异常都需要执行的代码，例如释放资源、关闭连接等。在异常处理过程中，finally块中的代码总会被执行，保证资源的释放。\n2.8 什么是异常处理的最佳实践？答：异常处理的最佳实践包括尽早捕获异常、准确抛出异常、避免空的catch块、适当使用finally块、理解并合理使用异常类型等。\n2.9 Error和Exception有什么区别？答：Error是指虚拟机相关的问题或者系统级别的问题，一般由虚拟机处理。Exception是指程序运行时出现的异常，需要程序员处理。\n2.10 什么是断言（assertion）和断言异常？答：断言用于在程序中进行验证和调试，通常用于在开发过程中检查程序的正确性。断言异常是一种特殊的异常，如java.lang.AssertionError，用于表示断言失败。\n2.11 什么是异常处理的原则？答：异常处理的原则包括“捕获并处理异常”、“仅捕获那些你能处理的异常”、“尽量不要捕获太宽泛的异常类型”和“使用合适的日志记录异常”。\n2.12 描述一下finally块中的return语句会如何影响方法的返回值？答：如果在finally块中使用了return语句，会覆盖在try块中使用的return语句，即以finally块中的return值为准。\n2.13 什么是异常的传递？答：异常的传递是指当一个方法抛出异常时，该异常会沿着调用栈向上传递，直到被捕获或者到达程序的顶层。\n2.14 什么是异常的过滤？答：异常的过滤是指在catch块中通过条件判断来筛选和处理特定的异常情况。\n2.15 在catch块中如何处理多个异常？答：可以使用多个catch块来处理不同的异常类型，或者使用一个catch块来处理多个异常类型，使用多个“|”分隔异常类型。\n2.16 什么是堆栈轨迹（Stack Trace）？答：堆栈轨迹是指异常抛出时输出的一系列方法调用的信息，包括方法名、行号等，用于追踪异常发生的路径。\n2.17 如何自定义异常？答：可以通过继承Exception或者RuntimeException类来创建自定义异常类，并添加相应的构造方法和其他属性。\n2.18 说一下NullPointerException和ArrayIndexOutOfBoundsException异常。答：NullPointerException是指访问空对象的属性或方法时抛出的异常，ArrayIndexOutOfBoundsException是指访问数组越界时抛出的异常。\n2.19 如何处理异常时避免内存泄漏？答：可以在catch块中及时释放资源，尤其是对于输入输出流、数据库连接等需要手动关闭的资源。\n2.20 异常捕获处理与错误码处理方式有何不同？答：异常捕获处理是一种以异常对象的形式表示程序执行中遇到的异常情况的方式，而错误码处理则是根据不同的情况返回不同的预定的错误码。 错误码处理相对简单，适用于简单的异常情况；异常捕获处理具有更好的可读性和可维护性，适用于复杂的异常情况。\n3. 常用类3.1 String是可变对象还是不可变对象？答：String是不可变对象，一旦创建就无法修改其值。每次对String进行修改操作都会生成一个新的String对象。\n3.2 如何比较两个String的值是否相等？答：可以使用equals方法来比较两个String的值是否相等（被重写过，实际上是比较的是内存地址），例如：String s1 &#x3D; “Hello”; String s2 &#x3D; “Hello”; s1.equals(s2)。\n3.3 &#x3D;&#x3D;和equals的区别？答：&#x3D;&#x3D;比较基本类型，比较的是值，&#x3D;&#x3D;比较引用类型，比较的是内存地址。\nequlas是Object类的方法，本质上与&#x3D;&#x3D;一样，但是有些类重写了equals方法，比如String的equals被重写后，比较的是内存地址，另外重写了equlas后，也必须重写hashcode()方法。\n3.4 String类的常用方法有哪些？答：String类的常用方法包括length()，charAt()，concat()，substring()，indexOf()，equals()，compareTo()等。\n3.5 String和StringBuilder&#x2F;StringBuffer的区别是什么？答：String是不可变对象，每次修改都会生成一个新的String对象；StringBuilder&#x2F;StringBuffer是可变对象，可以直接修改其值。\n3.6 StringBuilder和StringBuffer有何区别？答：StringBuilder是非线程安全的，适用于单线程环境下；StringBuffer是线程安全的，适用于多线程环境下。\n3.7 如何将一个字符串转换为大写字母或小写字母？答：可以使用**toUpperCase()方法将字符串转换为大写字母，使用toLowerCase()**方法将字符串转换为小写字母。\n3.8 如何判断一个字符串是否以特定的前缀或后缀开头或结尾？答：可以使用**startsWith()判断字符串是否以特定的前缀开头，使用endsWith()**判断字符串是否以特定的后缀结尾。\n3.9 如何将字符串拆分成数组或将数组拼接成字符串？答：可以使用**split()方法将字符串拆分成数组，使用join()**方法将数组拼接成字符串。\n3.10 如何去除字符串中的空格或特定的字符？答：可以使用**trim()方法去除字符串中的前后空格，使用replace()**方法替换指定的字符。\n3.11 String常量池是什么？答：String常量池是一个特殊的内存区域，用于存储字符串常量，避免重复创建相同的字符串对象。\n3.12 如何比较两个String对象的引用是否相等？答：可以使用&#x3D;&#x3D;操作符来比较两个String对象的引用是否相等，例如：String s1 &#x3D; “Hello”; String s2 &#x3D; “Hello”; s1 &#x3D;&#x3D; s2。\n3.13 如何判断一个字符串是否包含另一个字符串？答：可以使用**contains()**方法来判断一个字符串是否包含另一个字符串，例如：String str &#x3D; “Hello World”; str.contains(“Hello”)。\n3.14 如何将基本类型转换为对应的字符串表示？答：可以使用valueOf()方法将基本类型转换为对应的字符串表示，例如：String num &#x3D; String.valueOf(10);\n3.15 如何将字符串转换为对应的基本类型？答：可以使用**parseXXX()**方法将字符串转换为对应的基本类型，例如：int num &#x3D; Integer.parseInt(“10”);\n3.16 如何反转一个字符串？答：可以使用**StringBuilder&#x2F;StringBuffer的reverse()**方法来反转一个字符串，例如：StringBuilder sb &#x3D; new StringBuilder(“Hello”); sb.reverse();\n3.17 String类中的+操作符和concat()方法有何区别？答：String类中的+操作符底层实际上使用了StringBuilder&#x2F;StringBuffer的append()方法来进行字符串拼接；而concat()方法直接将字符串拼接。\n3.18 如何截取字符串的子串？答：可以使用**substring()**方法来截取字符串的子串，指定起始下标和结束下标，例如：String str &#x3D; “Hello World”; str.substring(6, 11);\n3.19 如何将字符串转换为字符数组？答：可以使用**toCharArray()**方法将字符串转换为字符数组，例如：String str &#x3D; “Hello”; char[] charArray &#x3D; str.toCharArray();\n3.20 如何将字符数组转换为字符串？答：可以使用String的构造方法或valueOf()方法将字符数组转换为字符串，例如：char[] charArray &#x3D; {‘H’, ‘e’, ‘l’, ‘l’, ‘o’}; String str &#x3D; new String(charArray);\n3.21 String对象的内存分配是放在栈上还是堆上？答：String对象的引用放在栈上，而String对象本身存储在堆上。\n3.22 如何将一个字符串转换为整数类型（int）？答：可以使用**Integer.parseInt()**方法将字符串转换为整数类型，例如：String str &#x3D; “123”; int num &#x3D; Integer.parseInt(str);\n3.23 如何将一个整数类型（int）转换为字符串？答：可以使用String.valueOf()方法或者将整数类型与空字符串相加（+” “）来将整数类型转换为字符串，例如：int num &#x3D; 123; String str &#x3D; String.valueOf(num); 或者 String str &#x3D; num + “”;\n3.24 如何判断一个字符串是否为空或者只包含空格？答：可以使用**isEmpty()方法或者trim()**方法（若含有空格）来判断一个字符串是否为空，例如：String str &#x3D; “”; boolean isEmpty &#x3D; str.isEmpty(); 或者 String str &#x3D; “ “; boolean isBlank &#x3D; str.trim().isEmpty();\n3.25 如何将一个字符串中的字符按照指定的分隔符拆分成数组？答：可以使用split()方法来将一个字符串按照指定的分隔符拆分成数组，例如：String str &#x3D; “Hello,World”; String[] arr &#x3D; str.split(“,”);\n3.26 如何将字符串中的字符全部替换为指定字符？答：可以使用replace()方法来将字符串中的字符全部替换为指定字符，例如：String str &#x3D; “Hello World”; String newStr &#x3D; str.replace(‘o’, ‘*’); \n3.27 如何将指定的字符插入到字符串指定的位置？答：可以使用substring()方法和concat()方法来将指定的字符插入到字符串指定的位置，例如：String str &#x3D; “Hello”; String newStr &#x3D; str.substring(0, 2).concat(“XX”).concat(str.substring(2));\n3.28 如何将字符串转换为大写或小写，并忽略字符串中的特殊字符？答：可以使用**toLowerCase()方法或toUpperCase()方法将字符串转换为大写或小写，并使用replaceAll()**方法去除特殊字符，例如：String str &#x3D; “Hello,@World!”; String lowerCase &#x3D; str.replaceAll(“[ ^a-zA-Z0-9 ]”, “”).toLowerCase();\n3.29 如何获取字符串中指定字符的索引位置？答：可以使用indexOf()方法或lastIndexOf()方法来获取字符串中指定字符的索引位置，例如：String str &#x3D; “Hello”; int index &#x3D; str.indexOf(‘o’);\n3.30 如何将多个字符串拼接成一个字符串？答：可以使**用StringBuilder&#x2F;StringBuffer的append()**方法进行字符串拼接，例如：StringBuilder sb &#x3D; new StringBuilder(); sb.append(“Hello”).append(“World”);\n3.31 如何判断两个字符串是否相等，忽略大小写？答：可以使用**equalsIgnoreCase()**方法来判断两个字符串是否相等，忽略大小写，例如：String str1 &#x3D; “Hello”; String str2 &#x3D; “hello”; boolean isEqual &#x3D; str1.equalsIgnoreCase(str2);\n3.32 Java中的八种基本类型与其对应的包装类分别是什么？答：八种基本类型及对应的包装类如下：boolean - Boolean、byte - Byte、char - Character、short - Short、int - Integer、long - Long、float - Float、double - Double。\n3.33 如何将基本类型转换为对应的包装类？答：可以使用包装类的构造方法或者**valueOf()**方法将基本类型转换为对应的包装类，例如：int num &#x3D; 10; Integer obj &#x3D; new Integer(num); 或者 Integer obj &#x3D; Integer.valueOf(num);\n3.34 如何将包装类转换为对应的基本类型？答：可以使用**包装类的xxxValue()**方法将包装类转换为对应的基本类型，例如：Integer obj &#x3D; new Integer(10); int num &#x3D; obj.intValue();\n3.35 如何将字符串转换为对应的包装类？答：可以使用**包装类的valueOf()**方法将字符串转换为对应的包装类，例如：String str &#x3D; “10”; Integer obj &#x3D; Integer.valueOf(str);\n3.36 如何将包装类转换为对应的字符串？答：可以使用**包装类的toString()**方法将包装类转换为对应的字符串，例如：Integer obj &#x3D; new Integer(10); String str &#x3D; obj.toString();\n3.37 如何比较两个包装类的值是否相等？答：可以使用equals()方法或**&#x3D;&#x3D;**操作符来比较两个包装类的值是否相等，例如：Integer obj1 &#x3D; new Integer(10); Integer obj2 &#x3D; new Integer(10); boolean isEqual &#x3D; obj1.equals(obj2) 或者 obj1 &#x3D;&#x3D; obj2;\n3.38 自动拆箱和自动装箱是什么意思？答：自动拆箱是指将包装类的对象自动转换为基本类型的过程，例如：Integer obj &#x3D; new Integer(10); int num &#x3D; obj; 自动装箱是指将基本类型自动转换为包装类的对象，例如：int num &#x3D; 10; Integer obj &#x3D; num;\n3.39 包装类和基本类型存储在内存中的位置有什么区别？答：基本类型的变量存储在栈内存中，而包装类对象存储在堆内存中。\n3.40 包装类的缓存是什么意思？答：在范围较小的数值范围中，Java的包装类会使用缓存来提高性能，例如Integer类会缓存-128至127之间的整数对象。\n3.41 在使用包装类时如何避免空指针异常？答：可以使用**包装类的valueOf()**方法，该方法如果传入的字符串为null，则会返回null值。例如：String str &#x3D; null; Integer obj &#x3D; Integer.valueOf(str);\n3.42 String赋值给包装类对象时会发生什么？答：当将一个String类型的值赋给包装类对象时，会自动调用包装类的valueOf()方法将字符串转换为包装类对象。\n3.43 包装类有哪些方法可以将字符串转换为对应的基本类型？答：包装类提供了许多方法将字符串转换为对应的基本类型，例如：Boolean类的parseBoolean()、Byte类的parseByte()、Integer类的parseInt()等。\n3.44 包装类的valueOf()方法和xxxValue()方法有什么区别？答：valueOf()方法将基本类型或字符串转换为包装类对象，xxxValue()方法将包装类对象转换为对应的基本类型。\n3.45 包装类对象如何比较大小？答：可以使用**包装类的compareTo()**方法来比较大小，或者将包装类对象转换为基本类型后再进行比较。\n3.46 为什么会出现基本类型和包装类之间的装箱和拆箱？答：基本类型和包装类之间的装箱和拆箱是为了在需要使用对象而只有基本类型的地方提供方便，同时也是为了实现一些储存和操作的需求。\n3.47 如何判断一个变量的类型是否是包装类？答：可以使用instanceof关键字来判断一个变量的类型是否是包装类，例如：if (obj instanceof Integer) { &#x2F;&#x2F; do something }\n3.48 包装类的作用是什么？答：包装类的主要作用是将基本类型转换为对象，以便于在需要使用对象的场景中进行操作，同时也提供了一些常用的方法和功能。\n3.49 在什么情况下会自动拆箱和自动装箱？答：自动拆箱和自动装箱在需要使用基本类型的地方进行拆箱操作，或者在需要使用对象的地方进行装箱操作。\n3.50 包装类和基本类型之间的转换会有什么影响？答：包装类和基本类型之间的转换会涉及到性能和内存消耗方面的影响，其中自动装箱和自动拆箱会带来一定的性能开销。 \n3.51 Java中处理日期和时间的类有哪些？答：Java中处理日期和时间的类主要有java.util.Date、java.util.Calendar、java.time.LocalDate、java.time.LocalDateTime等。\n3.52 如何获取当前的日期和时间？答：可以使用java.util.Date类的无参构造方法得到当前的日期和时间，或者使用**java.time.LocalDateTime的now()**方法。\n3.53 如何格式化日期和时间？答：可以使用java.text.SimpleDateFormat类来格式化日期和时间，通过指定格式的字符串将日期和时间转换为指定格式。\n3.54 如何在Java中表示一个特定的日期？答：可以使用java.util.Calendar类或java.time.LocalDate类来表示一个特定的日期。\n3.55 如何计算两个日期之间的天数差距？答：可以使用java.util.Calendar类或java.time.LocalDate类的方法来计算两个日期之间的天数差距，然后进行相减运算。\n3.56 如何将日期转换为字符串？答：可以使用java.util.Date类的toString()方法将日期对象转换为字符串，或者使用java.text.SimpleDateFormat类进行自定义格式的转换。\n3.57 如何将字符串转换为日期？答：可以使用java.text.SimpleDateFormat类的**parse()**方法将字符串转换为日期对象，需要指定匹配的日期格式。\n3.58 如何在Java中进行日期的加减操作？答：可以使用java.util.Calendar类或java.time.LocalDateTime类的**add()**方法进行日期的加减操作。\n3.59 Java中日期和时间的处理在多线程环境下是否安全？答：java.util.Date类和java.util.Calendar类在多线程环境下是不安全的，可以使用java.time包中的类来实现线程安全的日期和时间处理。\n3.60 Java中如何比较两个日期是否相等？答：可以使用java.util.Date类的equals()方法或者java.time.LocalDate类的isEqual()方法来判断两个日期是否相等。\n3.61 Java中如何获取某个日期的年、月、日、星期等具体信息？答：可以使用java.util.Calendar类或java.time.LocalDate类的**get()**方法来获取某个日期的年、月、日、星期、一年中的第几天等具体信息。\n3.62 Java中如何获取某个日期的下一天或上一天？答：可以使用java.util.Calendar类或java.time.LocalDate类的**add()**方法来进行日期的加减操作，从而得到下一天或上一天的日期。\n3.63 Java中如何判断某个日期是在另一个日期之前还是之后？答：可以使用java.util.Date类的**before()和after()**方法，或者使用java.time.LocalDate类的isBefore()和isAfter()方法来判断日期的先后关系。\n3.64 Java中如何将日期设置为零点或午夜？答：可以使用java.util.Calendar类或java.time.LocalDateTime类的**set()**方法来将日期设置为零点或午夜。\n3.65 Java中的String、StringBuffer和StringBuilder有什么区别？答：String是不可变类，每次对String的操作都会创建新的String对象，StringBuffer和StringBuilder是可变类，可以在原始字符串上进行修改。\n3.66 String、StringBuffer和StringBuilder之间的性能差异是什么？答：由于String是不可变的，每次对String进行操作时都会创建新的String对象，因此在频繁进行字符串操作时，使用StringBuffer和StringBuilder性能更好。 \n3.67 StringBuffer和StringBuilder之间的区别是什么？答：StringBuffer是线程安全的，适用于多线程环境，而StringBuilder是非线程安全的，适用于单线程环境。\n3.68 如何将String类型的字符串转换为StringBuffer或StringBuilder类型？答：可以使用StringBuffer或StringBuilder的构造方法将String类型的字符串转换为StringBuffer或StringBuilder类型，例如：StringBuffer sb &#x3D; new StringBuffer(“Hello”); 或者 StringBuilder sb &#x3D; new StringBuilder(“Hello”);\n3.69 如何在Java中连接多个字符串？答：可以使用”+“运算符进行字符串的连接，也可以使用**StringBuffer或StringBuilder的append()**方法进行字符串的连接。\n3.70 为什么String对象是不可变的？答：String对象是不可变的，主要是为了提高字符串的安全性和线程安全性。\n3.71 StringBuffer和StringBuilder的常用方法有哪些？答：StringBuffer和StringBuilder具有相似的方法，包括append()、insert()、delete()、replace()、reverse()等方法。\n3.72 何时应该使用StringBuffer，何时应该使用StringBuilder？答：应该在多线程环境下使用StringBuffer，因为它是线程安全的；在单线程环境下使用StringBuilder，因为它的性能更好。\n3.73 如何定义一个枚举类？答：可以使用enum关键字定义一个枚举类。\n3.74 枚举类的常量有什么特点？答：枚举类的常量是唯一的、有限的且已命名的，不能再次赋值。\n3.75 枚举类的常量可以有自己的属性和方法吗？答：是的，枚举类的常量可以有自己的属性和方法。\n3.76 如何访问枚举类中的常量？答：可以使用枚举类名和常量名来访问枚举类中的常量。\n3.77 枚举类可以实现接口吗？答：是的，枚举类可以实现一个或多个接口。\n3.78 如何遍历枚举类中的常量？答：可以使用枚举类的**values()**方法获取枚举类的所有常量，并进行遍历。\n3.79 如何通过字符串获取枚举类中的常量？答：可以使用枚举类的valueOf()方法，传入常量的字符串名称来获取对应的常量。\n3.80 枚举类与普通类的区别是什么？答：枚举类可以确保常量的唯一性且类型安全，可以直接比较和使用，而普通类则需要通过对象来比较和使用。\n3.81 枚举类在实际开发中的应用场景有哪些？答：枚举类在实际开发中常用于定义一组相关常量、状态机、单例模式等场景。\n3.82 如何比较两个枚举常量的顺序？答：可以使用枚举常量的**compareTo()**方法来比较两个枚举常量的顺序。\n3.83 枚举类的构造方法可以是私有的吗？答：是的，枚举类的构造方法可以是私有的。\n3.84 枚举类如何定义自己的方法？答：可以在枚举类中定义自己的方法，常量可以调用这些方法进行特定的操作。\n3.85 枚举类可以继承其他类吗？答：Java中的枚举类默认继承自java.lang.Enum类，不支持继承其他类。\n3.86 如何在枚举类中添加更多的属性？答：可以在枚举类中添加成员变量，并在构造方法中为其赋值，每个常量都会具有相应的属性。\n3.87 枚举类的构造方法在何时被调用？答：每个枚举常量的构造方法在枚举类加载时被调用。\n3.88 枚举类可以作为方法的参数和返回值吗？答：是的，枚举类可以作为方法的参数和返回值。\n3.89 如何扩展枚举类的功能？答：可以使用抽象方法，在枚举类的每个常量中实现该抽象方法，以便为每个常量定制不同的行为。\n123456789101112131415161718enum Color&#123;    RED&#123;        public String getColor()&#123;//枚举对象实现抽象方法            return &quot;红色&quot;;        &#125;    &#125;,    GREEN&#123;        public String getColor()&#123;//枚举对象实现抽象方法            return &quot;绿色&quot;;        &#125;    &#125;,    BLUE&#123;        public String getColor()&#123;//枚举对象实现抽象方法            return &quot;蓝色&quot;;        &#125;    &#125;;    public abstract String getColor();//定义抽象方法&#125;\n\n3.90 枚举类可以实现单例模式吗？答：是的，枚举类天然的单例模式可以保证线程安全和实例唯一性。  \n4. 多线程4.1 什么是线程？为什么要使用线程？答：线程是程序执行的最小单位，使用线程可以同时执行多个任务，提高程序的并发性和处理能力。\n4.2 Java中创建线程的方式有哪些？答：Java中创建线程的方式有两种：继承Thread类和实现Runnable接口。\n4.3 创建线程的方式中，哪种更常用？为什么？答：更常用的方式是实现Runnable接口，因为Java不支持多重继承，通过实现Runnable接口可以更好地组织和管理线程。\n4.4 如何启动一个线程？答：启动一个线程可以调用线程对象的**start()**方法。\n4.5 run()方法和start()方法有什么区别？答：run()方法是线程的执行方法，通过调用start()方法来启动线程，会自动调用run()方法。\n4.6 线程的生命周期有哪些状态？答：线程的生命周期包括新建状态、就绪状态、运行状态、阻塞状态和死亡状态。\n4.7 怎样停止一个正在运行的线程？答：通常使用标志位的方式停止一个线程，通过修改标志位来控制线程的执行。\n4.8 什么是线程安全？如何保证线程安全？答：线程安全是指多个线程访问共享数据时，不会出现数据不一致或数据冲突的情况。可以使用synchronized关键字或Lock接口来保证线程安全。\n4.9 什么是线程间通信？如何实现线程间通信？答：线程间通信是指多个线程之间通过发送和接收消息来进行协作。可以使用wait()、notify()和notifyAll()方法实现线程间通信。\n4.10 什么是线程死锁？如何避免线程死锁？答：线程死锁是指多个线程相互等待对方释放资源而无法继续执行的情况。可以避免线程死锁的方法包括避免循环等待、按照相同的顺序获取资源等。\n4.11 什么是线程优先级？如何设置线程优先级？答：线程优先级是操作系统对线程调度的参考值，可以使用setPriority()方法设置线程的优先级。\n4.12 什么是守护线程？答：守护线程是在后台运行的线程，当所有非守护线程结束时，守护线程会自动退出。\n4.13 什么是线程的上下文切换？在什么情况下会发生线程的上下文切换？答：线程的上下文切换是指CPU从一个线程切换到另一个线程执行的过程。线程的上下文切换会在多核CPU中或出现线程阻塞和线程优先级变化时发生。\n4.14 什么是线程池？为什么要使用线程池？答：线程池是一种管理和复用线程的机制，可以避免重复创建和销毁线程，提高资源利用率和系统性能。\n4.15 Java中如何使用线程池？答：可以通过ThreadPoolExecutor类或Executors工具类来创建线程池。\n4.16 线程池有哪些常用的创建方式？答：常用的创建线程池的方式有n**ewFixedThreadPool()、newCachedThreadPool()、newSingleThreadExecutor()**等。\n4.17 线程池的核心线程数和最大线程数有什么区别？答：核心线程数是线程池最少保留的线程数，最大线程数是线程池所能容纳的最大线程数。\n4.18 什么是线程池的拒绝策略？答：线程池的拒绝策略指当线程池中的任务队列已满并且线程数达到最大线程数时，线程池如何处理无法继续执行的任务。\n4.19 什么是线程局部变量？答：线程局部变量是每个线程独立拥有的变量，每个线程都可以对其进行读写操作。\n4.20 什么是ThreadLocal类？如何在多线程中使用ThreadLocal？答：ThreadLocal类是Java中用于存储线程局部变量的类，每个线程都有一个与之关联的ThreadLocal对象，通过ThreadLocal的get()和set()方法可以在多线程中访问和修改线程局部变量。\n4.21 Java中有几种锁的类型？请列举并简要解释。答：Java中有两种锁的类型，分别为对象锁（也称为内部锁或监视器锁）和类锁（也称为静态锁）。对象锁是在对象上的锁，使只有一个线程可以访问对象的同步代码块。类锁是在类上的锁，使只有一个线程可以访问类的同步代码块。\n4.22 synchronized关键字和Lock接口之间有什么区别？答：synchronized关键字是Java内置的锁机制，用于实现线程同步。Lock接口是Java提供的更灵活、更强大的锁机制，可以实现更复杂的同步方式。\n4.23 请解释一下volatile关键字的作用。答：volatile关键字用于保证被修饰的变量在多线程环境下的可见性和禁止指令重排序。它是一种轻量级的同步机制，适用于变量的读多写少的场景。\n4.24 Java中的线程调度算法是什么？如何改变线程的调度优先级？答：Java中的线程调度算法是抢占式调度算法（preemptive scheduling），通过线程的优先级来决定下一个应该执行的线程。可以使用setPriority()方法来改变线程的调度优先级。\n4.25 什么是线程安全的集合？Java中有哪些线程安全的集合类？答：线程安全的集合是在多线程环境下可以安全使用的集合。Java中有诸如Vector、Hashtable、ConcurrentHashMap、CopyOnWriteArrayList和ConcurrentLinkedQueue等线程安全的集合类。\n4.26 什么是线程的上下文ClassLoader？它有什么作用？答：线程的上下文ClassLoader是线程的一个属性，用于寻找和加载类文件。ClassLoader可以指定线程在运行时加载类所使用的类加载器。\n4.27 什么是线程的上下文切换开销？如何减少上下文切换开销？答：线程的上下文切换开销是指在同一CPU内核上切换线程所耗费的时间和资源。可以通过减少线程的数量、避免线程的频繁切换和优化线程的调度来减少上下文切换开销。\n4.28 什么是线程的运行状态不安全问题（Race Condition）？如何避免？答：线程的运行状态不安全问题是由于多个线程同时访问和修改共享数据而导致的不确定性问题。可以使用同步机制（如锁）或使用线程安全的数据结构来避免运行状态不安全问题。\n4.29 什么是线程的休眠和阻塞？答：线程的休眠是指让线程暂停一段时间执行，可以使用Thread.sleep()来实现。线程的阻塞是指暂停线程的执行，直到某个条件满足，可以使用Object类的wait()方法来实现。\n4.30 什么是线程的调度策略？Java中的线程调度策略是什么？答：线程的调度策略是指操作系统或虚拟机如何决定在何时执行哪个线程。Java中的线程调度策略是由操作系统控制，通常基于线程的优先级和调度算法来决定。\n4.31 什么是线程锁？答：线程锁是一种同步机制，用于保护共享资源在多线程环境下的安全访问。\n4.32 Java中有哪些线程锁机制？答：Java中有两种线程锁机制，分别为synchronized关键字和Lock接口。\n4.33 synchronized关键字的作用是什么？答：synchronized关键字用于实现线程的互斥访问，确保同一时刻只有一个线程可以访问被synchronized关键字保护的代码块。\n4.34 synchronized关键字有哪些使用方式？答：synchronized关键字可以修饰实例方法、静态方法和代码块。\n4.35 什么是悲观锁和乐观锁？答：悲观锁是指假设会发生并发冲突，每次访问共享资源都会加锁。乐观锁是指假设不会发生并发冲突，只有在更新时才检查是否有冲突。\n4.36 什么是可重入锁（Reentrant Lock）？答：可重入锁是指同一个线程可以多次获得同一个锁，用于解决线程在递归调用等情况下对资源的重复加锁问题。\n4.37 什么是读写锁（ReadWriteLock）？答：读写锁是一种特殊的锁机制，允许多个线程同时读取共享资源，但在写操作时只允许一个线程访问。\n4.38 什么是公平锁和非公平锁？答：公平锁是指线程按照请求的顺序获得锁，非公平锁是指线程在请求时不考虑顺序，有机会直接获得锁。\n4.39 如何避免死锁？答：避免死锁的方法包括避免循环等待、按照相同的顺序获取锁、设置超时时间等。\n4.40 什么是线程的通信？答：线程的通信是指多个线程之间通过共享变量进行交互和传递信息的过程。\n4.41 Java中如何进行线程的通信？答：Java中可以使用Object类的wait()、notify()和notifyAll()方法进行线程的通信。\n4.42 wait()和sleep()方法有什么区别？答：wait()方法是Object类的方法，用于暂停线程的执行，并释放锁；sleep()方法是Thread类的方法，用于暂停线程的执行，但不释放锁。\n4.43 为什么wait()、notify()和notifyAll()方法必须在synchronized块内调用？答：wait()、notify()和notifyAll()方法必须在synchronized块内调用，因为它们依赖于对象的监视器锁。\n4.44 wait()方法和notify()方法的调用顺序有要求吗？答：是的，wait()方法应该在notify()方法之前被调用。\n4.45 为什么调用notify()方法后，不会立即释放锁？答：调用notify()方法后，线程只是通知其他线程可以竞争锁，但不会立即释放锁。\n4.46 notify()方法会通知哪个线程？答：notify()方法会随机通知等待该对象锁的一个线程。\n4.47 notifyAll()方法会通知哪些线程？答：notifyAll()方法会通知等待该对象锁的所有线程，让它们重新竞争锁。\n4.48 为什么在调用wait()方法时，需要使用while循环来测试条件？答：在多线程环境下，wait()方法被唤醒后，线程仍需再次检查等待条件是否满足，以防止虚假唤醒。\n4.49 如何唤醒处于wait状态的线程？答：可以使用notify()方法或notifyAll()方法来唤醒处于wait状态的线程。\n4.50 wait()方法和await()方法有什么区别？答：wait()方法是Object类的方法，用于线程的等待；await()方法是Condition接口中的方法，用于线程的等待指定条件满足。\n4.51 为什么使用notifyAll()方法而不是notify()方法？答：使用notifyAll()方法可以通知所有等待该对象锁的线程，确保不会有线程被遗漏。\n4.52 如何防止线程的等待超时？答：可以使用wait()方法的重载版本**wait(long timeout)**来设置等待的超时时间。\n4.53 为什么wait()方法和notify()方法定义在Object类中而不是Thread类中？答：wait()方法和notify()方法定义在Object类中是因为每个对象都拥有一个锁和一个等待集，而线程只是操作对象的锁和等待集。\n4.54 为什么wait()方法和notify()方法被定义为final？答：wait()方法和notify()方法被定义为final，是为了防止子类对其进行重写。\n4.55 wait()方法和notify()方法会释放线程所拥有的锁吗？答：是的，调用wait()方法后，线程会释放它所拥有的锁，以供其他线程竞争。\n4.56 能否在非同步方法中调用wait()方法和notify()方法？答：不可以，在非同步方法中调用这些方法会抛出IllegalMonitorStateException异常。\n4.57 如何使用notify()方法和wait()方法实现线程间的协作？答：可以使用生产者-消费者模式，通过notify()方法唤醒消费者线程，然后消费者线程在消费完成后调用wait()方法等待生产者线程的唤醒。\n4.58 在多线程环境下，如何保证两个线程交替执行？答：可以使用wait()方法和notify()方法结合使用，让线程在合适的时机等待并唤醒。 \n4.59 优化这里的锁优化主要是指虚拟机对 synchronized 的优化。\n4.59.1 自旋锁互斥同步的进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。\n自选锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。\n4.59.2 锁消除锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。\n锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。\n对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：\n1public static String concatString(String s1, String s2, String s3) &#123; return s1 + s2 + s3; &#125;\n\nString 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：\n1234567public static String concatString(String s1, String s2, String s3) &#123;    StringBuffer sb = new StringBuffer();    sb.append(s1);    sb.append(s2);    sb.append(s3);        return sb.toString();&#125;\n\n每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会“逃逸”到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。\n4.59.3 锁粗化如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。\n上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。\n4.59.4 轻量级锁JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。\n轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。\n如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。\n4.59.5 偏向锁偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。\n当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。\n当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。\n4.60 volatile和synchronized的区别\nvolatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。\nvolatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的\nvolatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性\nvolatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。\nvolatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化\n\n4.61 synchronized 和 ReentrantLock 比较\n锁的实现：synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。\n\n性能：新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等。目前来看它和 ReentrantLock 的性能基本持平了，因此性能因素不再是选择 ReentrantLock 的理由。synchronized 有更大的性能优化空间，应该优先考虑 synchronized。\n\n功能：ReentrantLock 多了一些高级功能。\n\n使用选择：除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。\n\n\n","slug":"JavaSE面试问题总结——答案版","date":"2024-03-19T08:08:30.000Z","categories_index":"","tags_index":"八股","author_index":"Fausto Wu"},{"id":"55c312fa2e77afdfd966e3f29479617e","title":"Redis面试问题总结——答案版","content":"1. 常规问题1.1 什么是Redis，为什么用Redis？Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。\n• 读写性能优异：Redis能读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s （测试条件见下一节）。\n• 数据类型丰富：Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。\n• 原子性：Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。\n• 丰富的特性：Redis支持 publish&#x2F;subscribe, 通知, key 过期等特性。\n• 持久化：Redis支持RDB, AOF等持久化方式\n• 发布订阅：Redis支持发布&#x2F;订阅模式\n• 分布式：Redis Cluster\n1.2 为什么Redis 是单线程的以及为什么这么快？• redis完全基于内存,绝大部分请求是纯粹的内存操作,非常快速.\n• 数据结构简单,对数据操作也简单,redis中的数据结构是专门进行设计的\n• 采用单线程模型, 避免了不必要的上下文切换和竞争条件, 也不存在多线程或者多线程切换而消耗CPU, 不用考虑各种锁的问题, 不存在加锁, 释放锁的操作, 没有因为可能出现死锁而导致性能消耗\n• 使用了多路IO复用模型,非阻塞IO\n• 使用底层模型不同,它们之间底层实现方式及与客户端之间的 通信的应用协议不一样,Redis直接构建了自己的VM机制,因为一般的系统调用系统函数的话,会浪费一定的时间去移动和请求\n1.3. Redis 一般有哪些使用场景？可以结合自己的项目讲讲，比如\n• 热点数据的缓存\n缓存是Redis最常见的应用场景，之所有这么使用，主要是因为Redis读写性能优异。而且逐渐有取代**memcached**，成为首选服务端缓存的组件。而且，Redis内部是支持事务的，在使用时候能有效保证数据的一致性。\n• 限时业务的运用\nredis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。\n• 计数器相关问题\nredis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。\n• 分布式锁\n这个主要利用redis的setnx命令进行，setnx：”set if not exists”就是如果不存在则成功设置缓存同时返回1，否则返回0 ，这个特性在俞你奔远方的后台中有所运用，因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先 通过setnx设置一个lock，如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。\n在分布式锁的场景中，主要用在比如秒杀系统等。\n2. 数据类型和数据结构2.1 Redis 有哪些数据类型？ 5种基础数据类型，分别是：String、List、Set、Zset、Hash。\n结构类型结构存储的值结构的读写能力String字符串可以是字符串、整数或浮点数对整个字符串或字符串的一部分进行操作；对整数或浮点数进行自增或自减操作；List列表一个链表，链表上的每个节点都包含一个字符串对链表的两端进行push和pop操作，读取单个或多个元素；根据值查找或删除元素；Set集合包含字符串的无序集合字符串的集合，包含基础的方法有看是否存在添加、获取、删除；还包含计算交集、并集、差集等；Hash散列包含键值对的无序散列表包含方法有添加、获取、删除单个元素Zset有序集合和散列一样，用于存储键值对字符串成员与浮点数分数之间的有序映射；元素的排列顺序由分数的大小决定；包含方法有添加、获取、删除单个元素以及根据分值范围或成员来获取元素\n• 三种特殊的数据类型 分别是 HyperLogLogs（基数统计）， Bitmaps (位图) 和 geospatial （地理位置) \n2.2 谈谈Redis 的对象机制（redisObject)？比如说， 集合类型就可以由字典和整数集合两种不同的数据结构实现， 但是， 当用户执行 ZADD 命令时， 他&#x2F;她应该不必关心集合使用的是什么编码， 只要 Redis 能按照 ZADD 命令的指示， 将新元素添加到集合就可以了。\n这说明, 操作数据类型的命令除了要对键的类型进行检查之外, 还需要根据数据类型的不同编码进行多态处理.\n为了解决以上问题, Redis 构建了自己的类型系统, 这个系统的主要功能包括:\n• redisObject 对象.\n• 基于 redisObject 对象的类型检查.\n• 基于 redisObject 对象的显式多态函数.\n• 对 redisObject 进行分配、共享和销毁的机制. \n2.3 Redis 数据类型有哪些底层数据结构？• 简单动态字符串 - sds\n• 压缩列表 - ZipList\n• 快表 - QuickList\n• 字典&#x2F;哈希表 - Dict\n• 整数集 - IntSet\n• 跳表 - ZSkipList\n2.4 为什么要设计sds？定义：Redis中的SDS（Simple Dynamic Strings）是一种用于表示字符串的内部数据结构。\n123456struct sdshdr &#123;    int len; /* 存储字符串的长度 */    int alloc; /* 已经分配的总长度 */    unsigned char flags; /* 存的这个结构的类型,其中的最低3个bit用来表示header的类型,剩余5位未使用 */    char buf[]; /* 一个c字符串,用来存储真实的字符串 */&#125;;\n\n• 常数复杂度获取字符串长度\n由于 len 属性的存在，我们获取 SDS 字符串的长度只需要读取 len 属性，时间复杂度为 O(1)。而对于 C 语言，获取字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。通过 strlen key 命令可以获取 key 的字符串长度。\n• 杜绝缓冲区溢出\n我们知道在 C 语言中使用 strcat 函数来进行两个字符串的拼接，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。而对于 SDS 数据类型，在进行字符修改的时候，会首先根据记录的 len 属性检查内存空间是否满足需求，如果不满足，会进行相应的空间扩展，然后在进行修改操作，所以不会出现缓冲区溢出。\n• 减少修改字符串的内存重新分配次数\nC语言由于不记录字符串的长度，所以如果要修改字符串，必须要重新分配内存（先释放再申请），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。\n而对于SDS，由于len属性和alloc属性的存在，对于修改字符串SDS实现了空间预分配和惰性空间释放两种策略：\n惰性空间，就像人具有懒惰性一样，空间的分配也可以具有懒惰性，简单说，如果Chunk在刚开始没有分配这么多空间，而是在需要的时候按需进行扩容，这种方法既节省了空间的浪费，也使得内部造成的碎片不会太多。\n\n空间预分配：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。\n\n惰性空间释放：对字符串进行缩短操作时，程序不立即使用内存重新分配来回收缩短后多余的字节，而是使用 alloc 属性将这些字节的数量记录下来，等待后续使用。（当然SDS也提供了相应的API，当我们有需要时，也可以手动释放这些未使用的空间。）\n\n\n• 二进制安全\n因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取；而所有 SDS 的API 都是以处理二进制的方式来处理 buf 里面的元素，并且 SDS 不是以空字符串来判断是否结束，而是以 len 属性表示的长度来判断字符串是否结束。\n• 兼容部分 C 字符串函数\n虽然 SDS 是二进制安全的，但是一样遵从每个字符串都是以空字符串结尾的惯例，这样可以重用 C 语言库&lt;string.h&gt; 中的一部分函数。 \n2.5 Redis 一个字符串类型的值能存储最大容量是多少？512M\n2.6 为什么会设计Stream？用过Redis做消息队列的都了解，基于Reids的消息队列实现有很多种，例如：\n• PUB&#x2F;SUB，订阅&#x2F;发布模式\nRedis发布&#x2F;订阅（Pub&#x2F;Sub）是一种通信机制，将数据推到某个信息管道中，其他客户端可通过订阅这些管道来获取推送信息，以此用于消息的传输。由三部分组成：发布者（Publisher）、频道（Channel）、订阅者（Subscriber）。\n​\t但是发布订阅模式是无法持久化的，如果出现网络断开、Redis 宕机等，消息就会被丢弃；\n• 基于List LPUSH+BRPOP 或者 基于Sorted-Set 的实现\n\n使用LPUSH和BRPOP命令：LPUSH命令用于将一个或多个值插入到列表头部。BRPOP命令是RPOP的阻塞版本，它会移除并获得列表的最后一个元素，如果列表没有元素会阻塞列表直到等待时间超时或者收到一个元素。\n使用Sorted Set和BZPOPMAX命令：ZADD命令用于将一个或多个成员元素及其分数值加入到有序集当中。BZPOPMAX是ZPOPMAX的阻塞版本，它会移除并获取有序集合中分数最大的元素，如果有序集合为空，那么命令会阻塞，直到有元素添加到有序集合中或者指定的超时时间发生。\n\n​\t支持了持久化，但是不支持多播，分组消费等\n消费组消费图\n2.7 Redis Stream用在什么样场景？可用作时通信等，大数据分析，异地数据备份等\n客户端可以平滑扩展，提高处理能力\n2.8 Redis Stream消息ID的设计是否考虑了时间回拨的问题？XADD生成的1553439850328-0，就是Redis生成的消息ID，由两部分组成:时间戳-序号。时间戳是毫秒级单位，是生成消息的Redis服务器时间，它是个64位整型（int64）。序号是在这个毫秒时间点内的消息序号，它也是个64位整型。\n可以通过multi批处理，来验证序号的递增：\n由于一个redis命令的执行很快，所以可以看到在同一时间戳内，是通过序号递增来表示消息的。\n为了保证消息是有序的，因此Redis生成的ID是单调递增有序的。由于ID中包含时间戳部分，为了避免服务器时间错误而带来的问题（例如服务器时间延后了），Redis的每个Stream类型数据都维护一个latest_generated_id属性，用于记录最后一个消息的ID。若发现当前时间戳退后（小于latest_generated_id所记录的），则采用时间戳不变而序号递增的方案来作为新消息ID（这也是序号为什么使用int64的原因，保证有足够多的的序号），从而保证ID的单调递增性质。\n强烈建议使用Redis的方案生成消息ID，因为这种时间戳+序号的单调递增的ID方案，几乎可以满足你全部的需求。但同时，记住ID是支持自定义的，别忘了！ \n","slug":"Redis面试问题总结——答案版","date":"2024-03-18T13:00:00.000Z","categories_index":"","tags_index":"八股","author_index":"Fausto Wu"}]